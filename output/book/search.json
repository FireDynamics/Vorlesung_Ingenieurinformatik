[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Vorlesung Ingenieurinformatik",
    "section": "",
    "text": "Übersicht",
    "crumbs": [
      "Übersicht"
    ]
  },
  {
    "objectID": "index.html#allgemeine-infos",
    "href": "index.html#allgemeine-infos",
    "title": "Vorlesung Ingenieurinformatik",
    "section": "Allgemeine Infos",
    "text": "Allgemeine Infos\nDie Vorlesung Ingenieurinformatik an der Bergischen Universität Wuppertal wurde vom im Jahr 2019 gebildeten Lehrstuhl Computational Civil Engineering (CCE) übernommen. Der CCE-Lehrstuhl beschäftigt sich hauptsächlich mit der Erforschung und Entwicklung neuer computergestützter Modelle. Im Zentrum der Anwendung steht die numerische Simulation der Brand- und Rauchausbreitung in Gebäuden.\nDa sich das Skript in der Entwicklung befinden freuen wir uns über konstruktive Anregungen und Ihr Feedback. So können Sie Ihre Nachfolger unterstützen.\nAlle organisatorischen Informationen zum Ablauf finden Sie auf der CCE-Webseite zur Ingenieurinformatik.",
    "crumbs": [
      "Übersicht"
    ]
  },
  {
    "objectID": "index.html#kontakt",
    "href": "index.html#kontakt",
    "title": "Vorlesung Ingenieurinformatik",
    "section": "Kontakt",
    "text": "Kontakt\nSo erreichen Sie uns: * Als Teilnehmer der Vorlesung: am besten über den zugehörigen Moodle-Kurs an der Bergischen Universität Wuppertal * Externe Interessenten benutzten am besten unsere Emailliste * Kontaktmöglichkeiten zu einzelnen Personen finden Sie auf der Mitarbeiterwebseite",
    "crumbs": [
      "Übersicht"
    ]
  },
  {
    "objectID": "index.html#abschlussarbeiten",
    "href": "index.html#abschlussarbeiten",
    "title": "Vorlesung Ingenieurinformatik",
    "section": "Abschlussarbeiten",
    "text": "Abschlussarbeiten\nWir bieten Abschlussarbeiten (BA, MA, PhD) zu vielen verschiedenen Themen an * eine Themenübersicht und bereits betreuter Arbeiten finden Sie auf der Webseite der Abschlussarbeiten * Bei der Themenfindung kann auch die Übersicht unserer Publikationen helfen * Bei Interesse kontaktieren Sie bitte Lukas Arnold",
    "crumbs": [
      "Übersicht"
    ]
  },
  {
    "objectID": "index.html#english-version",
    "href": "index.html#english-version",
    "title": "Vorlesung Ingenieurinformatik",
    "section": "English Version",
    "text": "English Version\nIs an english version planned? Not yet, please contact Lukas Arnold.",
    "crumbs": [
      "Übersicht"
    ]
  },
  {
    "objectID": "books/w-python-minimal/index.html",
    "href": "books/w-python-minimal/index.html",
    "title": "Werkzeugbaustein Python",
    "section": "",
    "text": "Voraussetzungen\nKeine Voraussetzungen",
    "crumbs": [
      "Grundlagen Python",
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "books/w-python-minimal/index.html#lernziele",
    "href": "books/w-python-minimal/index.html#lernziele",
    "title": "Werkzeugbaustein Python",
    "section": "Lernziele",
    "text": "Lernziele\nIn diesem Bausteine werden die Grundzüge der Programmierung mit Python vermittelt. In diesem Baustein lernen Sie …\n\nGrundlagen des Programmierens\nAusgaben in Python, Grundlegende Datentypen, FLusskontrolle\ndie Dokumentation zu lesen und zu verwenden\nModule und Pakete laden",
    "crumbs": [
      "Grundlagen Python",
      "Werkzeugbaustein Python"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/einleitung.html",
    "href": "books/w-python-minimal/skript/einleitung.html",
    "title": "1  Einführung",
    "section": "",
    "text": "2 Willkommen bei Python!\nPython ist eine moderne Programmiersprache, die sich besonders gut für Einsteigerinnen und Einsteiger eignet. Sie ist leicht verständlich und wird in vielen Bereichen eingesetzt – von der Datenanalyse bis hin zur Webentwicklung.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/einleitung.html#lernziele-dieses-kapitels",
    "href": "books/w-python-minimal/skript/einleitung.html#lernziele-dieses-kapitels",
    "title": "1  Einführung",
    "section": "2.1 Lernziele dieses Kapitels",
    "text": "2.1 Lernziele dieses Kapitels\nAm Ende dieses Kapitels können Sie:\n\neinfache Python-Programme schreiben,\nText auf dem Bildschirm ausgeben,\nerste Variablen definieren und verwenden.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/einleitung.html#ihr-erstes-programm",
    "href": "books/w-python-minimal/skript/einleitung.html#ihr-erstes-programm",
    "title": "1  Einführung",
    "section": "2.2 Ihr erstes Programm",
    "text": "2.2 Ihr erstes Programm\nDie ersten Schritte in einer neuen Programmiersprache sind immer die gleichen. WIr lassen uns die Worte ‘Hello World’ ausgeben. Dazu nutzen wir den print-Befehl print():\n\nprint(\"Hallo Welt!\")\n\nHallo Welt!\n\n\nWas passiert hier? - print() ist eine sogenannte Funktion, die etwas auf dem Bildschirm ausgibt. - Der Text \"Hello World!\" wird angezeigt. - Texte (auch „Strings“ genannt) stehen immer in Anführungszeichen.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/einleitung.html#variablen-namen-für-werte",
    "href": "books/w-python-minimal/skript/einleitung.html#variablen-namen-für-werte",
    "title": "1  Einführung",
    "section": "2.3 Variablen – Namen für Werte",
    "text": "2.3 Variablen – Namen für Werte\nVariablen sind wie beschriftete Schubladen: Sie speichern Informationen unter einem Namen.\n\nname = \"Frau Müller\"\nalter = 32\n\nSie können diese Variablen verwenden, um dynamische Ausgaben zu erzeugen:\n\nprint(name + \" ist \" + str(alter) + \" Jahre alt.\")\n\nFrau Müller ist 32 Jahre alt.\n\n\nZu beachten ist hier, dass sie versuchen sowohl eine Zahl, als auch Text auszugeben. Daher müssen wir mit der Funktion ‘str()’ die Zahl in Text umwandeln.\n\n\n\n\n\n\n✏️ Aufgabe: Begrüßung mit Alter\n\n\n\n\n\nSchreiben Sie ein Programm, das Sie mit Ihrem Namen begrüßt:\nHallo Frau Müller!\nTipp: In Python können Sie Texte mit + zusammenfügen. Denken Sie daran, dass Strings in Anführungszeichen stehen müssen.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nmein_name = \"Ihr Name hier\"\nprint(\"Hallo \" + mein_name + \"!\")\n\nHallo Ihr Name hier!\n\n\n\n\n\nErweitern Sie Ihr Programm so, dass es eine Begrüßung inklusive Alter ausgibt:\nHallo Frau Müller!\nSie sind 32 Jahre alt.\nTipp: Verwenden Sie print() mehrmals oder fügen Sie Texte zusammen.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nname = \"Frau Müller\"\nalter = 32\n\nprint(\"Hallo \" + name + \"!\")\nprint(\"Sie sind \" + str(alter) + \" Jahre alt.\")\n\nHallo Frau Müller!\nSie sind 32 Jahre alt.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/datentypen.html",
    "href": "books/w-python-minimal/skript/datentypen.html",
    "title": "2  Datentypen verstehen",
    "section": "",
    "text": "2.1 Lernziele dieses Kapitels\nAm Ende dieses Kapitels können Sie:",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/datentypen.html#lernziele-dieses-kapitels",
    "href": "books/w-python-minimal/skript/datentypen.html#lernziele-dieses-kapitels",
    "title": "2  Datentypen verstehen",
    "section": "",
    "text": "die wichtigsten Datentypen unterscheiden,\nmit Zahlen und Texten rechnen bzw. arbeiten,\neinfache Berechnungen und Ausgaben erstellen.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/datentypen.html#einleitung",
    "href": "books/w-python-minimal/skript/datentypen.html#einleitung",
    "title": "2  Datentypen verstehen",
    "section": "2.2 Einleitung",
    "text": "2.2 Einleitung\nIn Python gibt es verschiedene Datentypen. Diese beschreiben, welche Art von Daten Sie in Variablen speichern. Das ist wichtig, weil viele Operationen – wie zum Beispiel + – je nach Datentyp etwas anderes bedeuten:\n\n+ bei Zahlen bedeutet Addition,\n+ bei Text bedeutet Zusammenfügen (Konkatenation).\n\nBevor wir also mit komplexeren Programmen arbeiten, sollten wir verstehen, welche Datentypen es gibt und wie man mit ihnen umgeht.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/datentypen.html#die-wichtigsten-datentypen",
    "href": "books/w-python-minimal/skript/datentypen.html#die-wichtigsten-datentypen",
    "title": "2  Datentypen verstehen",
    "section": "2.3 Die wichtigsten Datentypen",
    "text": "2.3 Die wichtigsten Datentypen\nHier sind die grundlegenden Datentypen in Python:\n\n\n\nTyp\nBeispiel\nBedeutung\n\n\n\n\nint\n10\nGanze Zahl\n\n\nfloat\n3.14\nKommazahl\n\n\nstr\n\"Hallo\"\nText (String)\n\n\nbool\nTrue, False\nWahrheitswert (Ja/Nein)\n\n\n\nSie können den Typ einer Variable mit der Funktion type() herausfinden:\n\nwert = 42\nprint(type(wert))  # Ausgabe: &lt;class 'int'&gt;\n\n&lt;class 'int'&gt;",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/datentypen.html#unterschiede-zwischen-int-und-float",
    "href": "books/w-python-minimal/skript/datentypen.html#unterschiede-zwischen-int-und-float",
    "title": "2  Datentypen verstehen",
    "section": "2.4 Unterschiede zwischen int und float",
    "text": "2.4 Unterschiede zwischen int und float\nIn Python unterscheidet man zwischen ganzen Zahlen (int) und Kommazahlen (float):\n\nint steht für „integer“ – also ganze Zahlen wie 1, 0, -10\nfloat steht für „floating point number“ – also Zahlen mit Dezimalstellen wie 3.14, 0.5, -2.0\n\n\na = 10       # int\nb = 2.5      # float\n\nprint(\"a:\", a, \"| Typ:\", type(a))\nprint(\"b:\", b, \"| Typ:\", type(b))\n\na: 10 | Typ: &lt;class 'int'&gt;\nb: 2.5 | Typ: &lt;class 'float'&gt;\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nDie Unterscheidung ist wichtig: Manche Rechenoperationen verhalten sich je nach Datentyp leicht unterschiedlich.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/datentypen.html#was-sind-booleans-bool",
    "href": "books/w-python-minimal/skript/datentypen.html#was-sind-booleans-bool",
    "title": "2  Datentypen verstehen",
    "section": "2.5 Was sind Booleans (bool)?",
    "text": "2.5 Was sind Booleans (bool)?\nEin Boolean ist ein Wahrheitswert: Er kann nur zwei Zustände annehmen:\n\nTrue (wahr)\nFalse (falsch)\n\nSolche Werte begegnen uns zum Beispiel bei Fragen wie:\n\nIst die Temperatur über 30 °C?\nHat die Datei einen bestimmten Namen?\nIst die Liste leer?\n\n\nist_sonnig = True\nhat_regenschirm = False\n\nprint(\"Sonnig:\", ist_sonnig)\nprint(\"Regenschirm dabei?\", hat_regenschirm)\nprint(\"Typ von 'ist_sonnig':\", type(ist_sonnig))\n\nSonnig: True\nRegenschirm dabei? False\nTyp von 'ist_sonnig': &lt;class 'bool'&gt;\n\n\nBooleans werden besonders in Bedingungen und Vergleichen verwendet, was Sie in Kapitel 4 genauer kennenlernen.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/datentypen.html#rechnen-mit-zahlen",
    "href": "books/w-python-minimal/skript/datentypen.html#rechnen-mit-zahlen",
    "title": "2  Datentypen verstehen",
    "section": "2.6 Rechnen mit Zahlen",
    "text": "2.6 Rechnen mit Zahlen\nPython kann wie ein Taschenrechner verwendet werden:\n\n\n\nOperator\nBeschreibung\n\n\n\n\n+, -\nAddition / Subtraktion\n\n\n*, /\nMultiplikation / Division\n\n\n//, %\nGanzzahlige Division / Rest\n\n\n**\nPotenzieren\n\n\n\n\na = 10\nb = 3\n\nprint(\"Addition:\", a + b)\nprint(\"Subtraktion:\", a - b)\nprint(\"Multiplikation:\", a * b)\nprint(\"Potenzieren\", a**b)\nprint(\"Division:\", a / b)\nprint(\"Ganzzahlige Division:\", a // b)\nprint(\"Division mit Rest:\", a % b)\n\nAddition: 13\nSubtraktion: 7\nMultiplikation: 30\nPotenzieren 1000\nDivision: 3.3333333333333335\nGanzzahlige Division: 3\nDivision mit Rest: 1\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n// bedeutet: Ganzzahldivision, das Ergebnis wird abgerundet. Alternativ gibt es auch %. Hier wird eine Ganzzahldivision durchgeführt und der Rest ausgegeben.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/datentypen.html#arbeiten-mit-text",
    "href": "books/w-python-minimal/skript/datentypen.html#arbeiten-mit-text",
    "title": "2  Datentypen verstehen",
    "section": "2.7 Arbeiten mit Text",
    "text": "2.7 Arbeiten mit Text\nTexte (Strings) können miteinander kombiniert werden:\n\nvorname = \"Anna\"\nnachname = \"Beispiel\"\nprint(\"Willkommen, \" + vorname + \" \" + nachname + \"!\")\n\nWillkommen, Anna Beispiel!\n\n\nWenn Sie Text und Zahlen kombinieren wollen, müssen Sie die Zahl in einen String umwandeln:\n\npunkte = 95\nprint(\"Sie haben \" + str(punkte) + \" Punkte erreicht.\")\n\nSie haben 95 Punkte erreicht.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/datentypen.html#umwandlung-von-datentypen-typecasting",
    "href": "books/w-python-minimal/skript/datentypen.html#umwandlung-von-datentypen-typecasting",
    "title": "2  Datentypen verstehen",
    "section": "2.8 Umwandlung von Datentypen (Typecasting)",
    "text": "2.8 Umwandlung von Datentypen (Typecasting)\nManchmal müssen Sie einen Wert von einem Datentyp in einen anderen umwandeln – z. B. eine Zahl in einen Text (String), damit sie ausgegeben werden kann.\nDas nennt man Typecasting. Hier sind die wichtigsten Funktionen dafür:\n\n\n\nFunktion\nBeschreibung\nBeispiel\n\n\n\n\nstr())\nZahl → Text\nstr(42) → \"42\"\n\n\nint()\nText/Zahl → ganze Zahl\nint(\"10\") → 10\n\n\nfloat()\nText/Zahl → Kommazahl\nfloat(\"3.14\") → 3.14\n\n\n\n\n# Beispiel: Zahl als Text anzeigen\npunkte = 100\nprint(\"Sie haben \" + str(punkte) + \" Punkte.\")\n\n# Beispiel: String in Zahl umwandeln und berechnen\neingabe = \"3.5\"\nwert = float(eingabe) * 2\nprint(\"Doppelt so viel:\", wert)\n\nSie haben 100 Punkte.\nDoppelt so viel: 7.0\n\n\nAchten Sie beim Umwandeln darauf, dass der Inhalt auch wirklich passt – int(\"abc\") führt zu einem Fehler.\n\n\n\n\n\n\nAufgabe: Alter in Tagen\n\n\n\n\n\nBerechnen Sie, wie alt eine Person in Tagen ist.\n\nalter_jahre = 32\ntage = alter_jahre * 365\nprint(\"Sie sind ungefähr \" + str(tage) + \" Tage alt.\")\n\nSie sind ungefähr 11680 Tage alt.\n\n\nTipp: Denken Sie an die Umwandlung in einen String, wenn Sie die Zahl ausgeben möchten.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nalter = 32\ntage = alter * 365\nprint(\"Sie sind ungefähr \" + str(tage) + \" Tage alt.\")\n\nSie sind ungefähr 11680 Tage alt.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datentypen verstehen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/flusskontrolle.html",
    "href": "books/w-python-minimal/skript/flusskontrolle.html",
    "title": "3  Entscheidungen und Wiederholungen",
    "section": "",
    "text": "3.1 Lernziele dieses Kapitels\nProgramme müssen oft Entscheidungen treffen – zum Beispiel abhängig von einer Benutzereingabe oder einem bestimmten Wert. Ebenso müssen bestimmte Aktionen mehrfach durchgeführt werden.\nDafür gibt es zwei zentrale Elemente in Python:\nAm Ende dieses Kapitels können Sie:",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/flusskontrolle.html#lernziele-dieses-kapitels",
    "href": "books/w-python-minimal/skript/flusskontrolle.html#lernziele-dieses-kapitels",
    "title": "3  Entscheidungen und Wiederholungen",
    "section": "",
    "text": "Bedingungen formulieren und mit if, elif, else nutzen,\nVergleichsoperatoren verwenden (==, &lt;, !=, …),\nWiederholungen mit while und for umsetzen.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/flusskontrolle.html#bedingungen-mit-if-elif-else",
    "href": "books/w-python-minimal/skript/flusskontrolle.html#bedingungen-mit-if-elif-else",
    "title": "3  Entscheidungen und Wiederholungen",
    "section": "3.2 Bedingungen mit if, elif, else",
    "text": "3.2 Bedingungen mit if, elif, else\n\nalter = 17\n\nif alter &gt;= 18:\n    print(\"Sie sind volljährig.\")\nelse:\n    print(\"Sie sind minderjährig.\")\n\nSie sind minderjährig.\n\n\nMehrere Fälle unterscheiden:\n\nnote = 2.3\n\nif note &lt;= 1.5:\n    print(\"Sehr gut\")\nelif note &lt;= 2.5:\n    print(\"Gut\")\nelif note &lt;= 3.5:\n    print(\"Befriedigend\")\nelse:\n    print(\"Ausreichend oder schlechter\")\n\nGut",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/flusskontrolle.html#vergleichsoperatoren",
    "href": "books/w-python-minimal/skript/flusskontrolle.html#vergleichsoperatoren",
    "title": "3  Entscheidungen und Wiederholungen",
    "section": "3.3 Vergleichsoperatoren",
    "text": "3.3 Vergleichsoperatoren\n\n\n\nAusdruck\nBedeutung\n\n\n\n\na == b\ngleich\n\n\na != b\nungleich\n\n\na &lt; b\nkleiner als\n\n\na &gt; b\ngrößer als\n\n\na &lt;= b\nkleiner oder gleich\n\n\na &gt;= b\ngrößer oder gleich",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/flusskontrolle.html#wiederholungen-mit-while",
    "href": "books/w-python-minimal/skript/flusskontrolle.html#wiederholungen-mit-while",
    "title": "3  Entscheidungen und Wiederholungen",
    "section": "3.4 Wiederholungen mit while",
    "text": "3.4 Wiederholungen mit while\n\nzähler = 0\n\nwhile zähler &lt; 5:\n    print(\"Zähler ist:\", zähler)\n    zähler += 1\n\nZähler ist: 0\nZähler ist: 1\nZähler ist: 2\nZähler ist: 3\nZähler ist: 4\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nAchten Sie auf eine Abbruchbedingung – sonst läuft die Schleife endlos!",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/flusskontrolle.html#schleifen-mit-for-und-range",
    "href": "books/w-python-minimal/skript/flusskontrolle.html#schleifen-mit-for-und-range",
    "title": "3  Entscheidungen und Wiederholungen",
    "section": "3.5 Schleifen mit for und range()",
    "text": "3.5 Schleifen mit for und range()\nWenn Sie eine Schleife genau eine bestimmte Anzahl von Malen durchlaufen möchten, nutzen Sie for mit range():\n\nfor i in range(5):\n    print(\"Durchlauf:\", i)\n\nDurchlauf: 0\nDurchlauf: 1\nDurchlauf: 2\nDurchlauf: 3\nDurchlauf: 4\n\n\nStart- und Endwert festlegen:\n\nfor i in range(1, 6):\n    print(i)\n\n1\n2\n3\n4\n5",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/flusskontrolle.html#was-macht-range-genau",
    "href": "books/w-python-minimal/skript/flusskontrolle.html#was-macht-range-genau",
    "title": "3  Entscheidungen und Wiederholungen",
    "section": "3.6 Was macht range() genau?",
    "text": "3.6 Was macht range() genau?\nDie Funktion range() erzeugt eine Abfolge von Zahlen, über die Sie mit einer for-Schleife iterieren können.\n\n3.6.1 Varianten:\nrange(5)\n➡️ ergibt: 0, 1, 2, 3, 4 (startet bei 0, endet vor 5)\nrange(2, 6)\n➡️ ergibt: 2, 3, 4, 5 (startet bei 2, endet vor 6)\nrange(1, 10, 2)\n➡️ ergibt: 1, 3, 5, 7, 9 (Schrittweite = 2)\nrange() erzeugt keine echte Liste, sondern ein sogenanntes „range-Objekt“, das wie eine Liste verwendet werden kann.\n\n\n\n\n\n\n✏️ Aufgabe: Zähle von 1 bis 10\n\n\n\n\n\nNutzen Sie eine for-Schleife, um die Zahlen von 1 bis 10 auszugeben.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nfor i in range(1, 11):\n    print(i)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAufgabe: Gerade Zahlen ausgeben\n\n\n\n\n\nGeben Sie alle geraden Zahlen von 0 bis 20 aus. Tipp: Eine Zahl ist gerade, wenn zahl % 2 == 0.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nfor zahl in range(0, 21):\n    if zahl % 2 == 0:\n        print(zahl)\n\n0\n2\n4\n6\n8\n10\n12\n14\n16\n18\n20",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Entscheidungen und Wiederholungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/listen_iterationen.html",
    "href": "books/w-python-minimal/skript/listen_iterationen.html",
    "title": "4  Mehrere Werte speichern",
    "section": "",
    "text": "4.1 Was ist eine Liste?\nBisher haben Sie einzelne Werte in Variablen gespeichert. Doch was, wenn Sie eine ganze Reihe von Zahlen, Namen oder Werten auf einmal speichern möchten?\nDafür gibt es in Python Listen. In diesem Kapitel lernen Sie außerdem, wie man mit for-Schleifen über Listen iteriert.\nEine Liste ist eine geordnete Sammlung von Werten eines Datentyps.\nnamen = [\"Ali\", \"Bente\", \"Carlos\"]\nnoten = [1.7, 2.3, 1.3, 2.0]\nAuf Elemente greifen Sie mit eckigen Klammern zu:\nprint(namen[0])  # erstes Element\nprint(noten[-1]) # letztes Element\n\nAli\n2.0",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mehrere Werte speichern</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/listen_iterationen.html#teile-aus-listen-ausschneiden-slicing",
    "href": "books/w-python-minimal/skript/listen_iterationen.html#teile-aus-listen-ausschneiden-slicing",
    "title": "4  Mehrere Werte speichern",
    "section": "4.2 Teile aus Listen ausschneiden – Slicing",
    "text": "4.2 Teile aus Listen ausschneiden – Slicing\nMit dem sogenannten Slicing können Sie gezielt Ausschnitte aus einer Liste entnehmen. Dabei geben Sie an, wo der Ausschnitt beginnt und wo er endet (der Endwert wird nicht mehr mitgenommen):\n\nzahlen = [10, 20, 30, 40, 50, 60]\nprint(zahlen[1:4])  # Ausgabe: [20, 30, 40]\n\n[20, 30, 40]\n\n\n\n4.2.1 Syntax: liste[start:stop]\n\nstart: Index, bei dem das Slicing beginnt (inklusive)\nstop: Index, an dem es endet (exklusive)\nDer Startwert kann auch weggelassen werden: [:3] → erstes bis drittes Element\nEbenso der Endwert: [3:] → ab dem vierten Element bis zum Ende\nGanze Kopie: [:]\n\n\nprint(zahlen[:3])   # [10, 20, 30]\nprint(zahlen[3:])   # [40, 50, 60]\nprint(zahlen[:])    # vollständige Kopie\n\n[10, 20, 30]\n[40, 50, 60]\n[10, 20, 30, 40, 50, 60]\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nSie können auch mit negativen Indizes arbeiten (-1 ist das letzte Element):\n\nprint(zahlen[-3:])  # [40, 50, 60]\n\n[40, 50, 60]",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mehrere Werte speichern</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/listen_iterationen.html#über-listen-iterieren",
    "href": "books/w-python-minimal/skript/listen_iterationen.html#über-listen-iterieren",
    "title": "4  Mehrere Werte speichern",
    "section": "4.3 Über Listen iterieren",
    "text": "4.3 Über Listen iterieren\nMit einer for-Schleife können Sie über jedes Element in einer Liste iterieren:\n\nnamen = [\"Ali\", \"Bente\", \"Carlos\"]\n\nfor name in namen:\n    print(\"Hallo\", name + \"!\")\n\nHallo Ali!\nHallo Bente!\nHallo Carlos!",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mehrere Werte speichern</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/listen_iterationen.html#erweiterung-bedingte-ausgaben",
    "href": "books/w-python-minimal/skript/listen_iterationen.html#erweiterung-bedingte-ausgaben",
    "title": "4  Mehrere Werte speichern",
    "section": "4.4 Erweiterung: Bedingte Ausgaben",
    "text": "4.4 Erweiterung: Bedingte Ausgaben\nSie können in der Schleife mit if filtern:\n\ntemperaturen = [14.2, 17.5, 19.0, 21.3, 18.4]\n\nfor t in temperaturen:\n    if t &gt; 18:\n        print(t, \"ist ein warmer Tag\")\n\n19.0 ist ein warmer Tag\n21.3 ist ein warmer Tag\n18.4 ist ein warmer Tag",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mehrere Werte speichern</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/listen_iterationen.html#durchschnitt-berechnen",
    "href": "books/w-python-minimal/skript/listen_iterationen.html#durchschnitt-berechnen",
    "title": "4  Mehrere Werte speichern",
    "section": "4.5 Durchschnitt berechnen",
    "text": "4.5 Durchschnitt berechnen\nPython stellt nützliche Funktionen bereit, z. B. sum() und len():\n\nnoten = [1.7, 2.3, 1.3, 2.0]\n\ndurchschnitt = sum(noten) / len(noten)\nprint(\"Durchschnittsnote:\", round(durchschnitt, 2))\n\nDurchschnittsnote: 1.82",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mehrere Werte speichern</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/listen_iterationen.html#listen-erweitern-.append",
    "href": "books/w-python-minimal/skript/listen_iterationen.html#listen-erweitern-.append",
    "title": "4  Mehrere Werte speichern",
    "section": "4.6 Listen erweitern: .append()",
    "text": "4.6 Listen erweitern: .append()\nManchmal kennen Sie die Listenelemente nicht vorher – dann können Sie neue Werte nachträglich hinzufügen:\n\nnamen = []\n\nnamen.append(\"Ali\")\nnamen.append(\"Bente\")\n\nprint(namen)\n\n['Ali', 'Bente']\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\nDie Methode .append()) hängt einen neuen Wert an das Ende der Liste.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mehrere Werte speichern</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/listen_iterationen.html#verschachtelte-schleifen",
    "href": "books/w-python-minimal/skript/listen_iterationen.html#verschachtelte-schleifen",
    "title": "4  Mehrere Werte speichern",
    "section": "4.7 Verschachtelte Schleifen",
    "text": "4.7 Verschachtelte Schleifen\nWenn Sie mit mehrdimensionalen Daten arbeiten – z. B. eine Tabelle mit mehreren Zeilen – können Sie Schleifen ineinander verschachteln:\n\nwochentage = [\"Mo\", \"Di\", \"Mi\"]\nstunden = [1, 2, 3]\n\nfor tag in wochentage:\n    for stunde in stunden:\n        print(f\"{tag}, Stunde {stunde}\")\n\nMo, Stunde 1\nMo, Stunde 2\nMo, Stunde 3\nDi, Stunde 1\nDi, Stunde 2\nDi, Stunde 3\nMi, Stunde 1\nMi, Stunde 2\nMi, Stunde 3\n\n\nDas ergibt:\nMo, Stunde 1\nMo, Stunde 2\nMo, Stunde 3\nDi, Stunde 1\n...",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mehrere Werte speichern</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/listen_iterationen.html#listen-sortieren",
    "href": "books/w-python-minimal/skript/listen_iterationen.html#listen-sortieren",
    "title": "4  Mehrere Werte speichern",
    "section": "4.8 Listen sortieren",
    "text": "4.8 Listen sortieren\nMit sorted() können Sie Listen alphabetisch oder numerisch sortieren:\n\nnamen = [\"Zoe\", \"Anna\", \"Ben\"]\nsortiert = sorted(namen)\n\nprint(sortiert)\n\n['Anna', 'Ben', 'Zoe']\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nDie Original-Liste bleibt unverändert.\nWenn Sie die Liste direkt verändern möchten, geht das mit:\n\nnamen.sort()",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Mehrere Werte speichern</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/funktionen.html",
    "href": "books/w-python-minimal/skript/funktionen.html",
    "title": "5  Wiederverwendbarer Code mit Funktionen",
    "section": "",
    "text": "5.1 Lernziele dieses Kapitels\nStellen Sie sich vor, Sie müssen eine bestimmte Berechnung mehrfach im Programm durchführen. Anstatt den Code jedes Mal neu zu schreiben, können Sie ihn in einer Funktion bündeln.\nFunktionen sind ein zentrales Werkzeug, um Code:\nAm Ende dieses Kapitels können Sie:",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wiederverwendbarer Code mit Funktionen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/funktionen.html#lernziele-dieses-kapitels",
    "href": "books/w-python-minimal/skript/funktionen.html#lernziele-dieses-kapitels",
    "title": "5  Wiederverwendbarer Code mit Funktionen",
    "section": "",
    "text": "eigene Funktionen mit def erstellen,\nParameter übergeben und Rückgabewerte nutzen,\nFunktionen sinnvoll in Programmen einsetzen.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wiederverwendbarer Code mit Funktionen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/funktionen.html#eine-funktion-definieren",
    "href": "books/w-python-minimal/skript/funktionen.html#eine-funktion-definieren",
    "title": "5  Wiederverwendbarer Code mit Funktionen",
    "section": "5.2 Eine Funktion definieren",
    "text": "5.2 Eine Funktion definieren\nEine Funktion besteht aus folgenden Teilen:\n\nDefinition mit def\nFunktionsname\nParameter in Klammern (optional)\nEinrückung für den Funktionskörper\n(optional) return-Anweisung\n\nBeispiel:\n\ndef hallo(name=\"Gast\"):\n    begruessung = \"Hallo \" + name + \"!\"\n    return begruessung\n\nFangen wir mit dem ersten Stichwort an. Funktionen werden mit def definiert und können beliebig oft aufgerufen werden:\n\ndef begruessung():\n    print(\"Hallo und willkommen!\")\n\nSie wird erst ausgeführt, wenn Sie sie aufrufen:\n\nbegruessung()\n\nHallo und willkommen!",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wiederverwendbarer Code mit Funktionen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/funktionen.html#parameter-übergeben",
    "href": "books/w-python-minimal/skript/funktionen.html#parameter-übergeben",
    "title": "5  Wiederverwendbarer Code mit Funktionen",
    "section": "5.3 Parameter übergeben",
    "text": "5.3 Parameter übergeben\nFunktionen können Eingabewerte (Parameter) erhalten:\n\ndef begruessung(name):\n    print(\"Hallo\", name + \"!\")\n\nbegruessung(\"Alex\")\n\nHallo Alex!",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wiederverwendbarer Code mit Funktionen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/funktionen.html#rückgabewerte-mit-return",
    "href": "books/w-python-minimal/skript/funktionen.html#rückgabewerte-mit-return",
    "title": "5  Wiederverwendbarer Code mit Funktionen",
    "section": "5.4 Rückgabewerte mit return",
    "text": "5.4 Rückgabewerte mit return\nEine Funktion kann auch einen Wert zurückgeben:\n\ndef quadrat(zahl):\n    return zahl * zahl\n\nergebnis = quadrat(5)\nprint(ergebnis)\n\n25",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wiederverwendbarer Code mit Funktionen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/funktionen.html#beispiel-umrechnungen",
    "href": "books/w-python-minimal/skript/funktionen.html#beispiel-umrechnungen",
    "title": "5  Wiederverwendbarer Code mit Funktionen",
    "section": "5.5 Beispiel: Umrechnungen",
    "text": "5.5 Beispiel: Umrechnungen\n\n5.5.1 Euro zu US-Dollar\n\ndef euro_zu_usd(betrag_euro):\n    wechselkurs = 1.09\n    return betrag_euro * wechselkurs\n\nprint(\"20 € sind\", euro_zu_usd(20), \"US-Dollar.\")\n\n20 € sind 21.8 US-Dollar.\n\n\n\n\n\n\n\n\nAufgabe: Begrüßung mit Name\n\n\n\n\n\nErstellen Sie eine Funktion begruesse(name), die den Namen in einem Begrüßungstext verwendet:\nHallo Fatima, schön dich zu sehen!\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\ndef begruesse(name):\n    print(\"Hallo\", name + \", schön dich zu sehen!\")\n\nbegruesse(\"Fatima\")\n\nHallo Fatima, schön dich zu sehen!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAufgabe: Temperaturumrechnung\n\n\n\n\n\nSchreiben Sie eine Funktion, die Celsius in Fahrenheit umrechnet:\nFormel: [ F = C + 32 ]\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\ndef celsius_zu_fahrenheit(c):\n    return c * 1.8 + 32\n\nprint(celsius_zu_fahrenheit(20))\n\n68.0",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wiederverwendbarer Code mit Funktionen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/funktionen.html#parameter-mit-standardwerten",
    "href": "books/w-python-minimal/skript/funktionen.html#parameter-mit-standardwerten",
    "title": "5  Wiederverwendbarer Code mit Funktionen",
    "section": "5.6 Parameter mit Standardwerten",
    "text": "5.6 Parameter mit Standardwerten\nSie können Parametern Standardwerte zuweisen. So kann die Funktion auch ohne Angabe eines Werts aufgerufen werden:\n\ndef begruessung(name=\"Gast\"):\n    print(\"Hallo\", name + \"!\")\n\nbegruessung()         # Hallo Gast!\nbegruessung(\"Maria\")  # Hallo Maria!\n\nHallo Gast!\nHallo Maria!\n\n\n\n\n\n\n\n\nprint() vs. return\n\n\n\n\n\nDiese beiden Begriffe werden oft verwechselt:\n\n\n\nAusdruck\nBedeutung\n\n\n\n\nprint()\nzeigt einen Text auf dem Bildschirm\n\n\nreturn\ngibt einen Wert an den Aufrufer zurück\n\n\n\nBeispiel:\n\ndef verdoppeln(x):\n    return x * 2\n\n# Ausgabe sichtbar machen\nprint(verdoppeln(5))  # Ausgabe: 10\n\n10",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Wiederverwendbarer Code mit Funktionen</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/lesen_schreiben.html",
    "href": "books/w-python-minimal/skript/lesen_schreiben.html",
    "title": "6  Arbeiten mit Dateien",
    "section": "",
    "text": "6.1 Lernziele dieses Kapitels\nProgramme arbeiten oft nicht nur mit Benutzereingaben, sondern auch mit Textdateien – zum Beispiel um Daten zu speichern oder zu laden.\nPython bietet einfache Funktionen, um:\nAm Ende dieses Kapitels können Sie:",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arbeiten mit Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/lesen_schreiben.html#lernziele-dieses-kapitels",
    "href": "books/w-python-minimal/skript/lesen_schreiben.html#lernziele-dieses-kapitels",
    "title": "6  Arbeiten mit Dateien",
    "section": "",
    "text": "Dateien mit open() öffnen,\nInhalte aus Textdateien einlesen,\nTexte in Dateien schreiben,\nmit with-Blöcken sicher und einfach arbeiten.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arbeiten mit Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/lesen_schreiben.html#eine-datei-einlesen",
    "href": "books/w-python-minimal/skript/lesen_schreiben.html#eine-datei-einlesen",
    "title": "6  Arbeiten mit Dateien",
    "section": "6.2 Eine Datei einlesen",
    "text": "6.2 Eine Datei einlesen\n\n# Beispiel: Datei lesen\nwith open(\"01-daten/beispiel.txt\", \"r\") as datei:\n    inhalt = datei.read()\n    print(inhalt)\n\nDies ist ein Test.\n\n\n\n\"r\" steht für read (lesen).\nwith sorgt dafür, dass die Datei nach dem Lesen automatisch geschlossen wird.\nread() liest den gesamten Inhalt der Datei als String.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arbeiten mit Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/lesen_schreiben.html#zeilenweise-lesen",
    "href": "books/w-python-minimal/skript/lesen_schreiben.html#zeilenweise-lesen",
    "title": "6  Arbeiten mit Dateien",
    "section": "6.3 Zeilenweise lesen",
    "text": "6.3 Zeilenweise lesen\n\nwith open(\"01-daten/beispiel.txt\", \"r\") as datei:\n    for zeile in datei:\n        print(\"Zeile:\", zeile.strip())\n\nZeile: Dies ist ein Test.\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n.strip() entfernt Leerzeichen und Zeilenumbrüche am Anfang und Ende.\n\n\n\n\n\n\n\n\n\nAufgabe: Datei lesen\n\n\n\n\n\nAngenommen, es gibt eine Datei gruesse.txt mit folgendem Inhalt:\nHallo Anna\nGuten Morgen Ben\nWillkommen Carla\nSchreiben Sie ein Programm, das jede Zeile einzeln einliest und mit print(...) wiedergibt.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nwith open(\"01-daten/gruesse.txt\", \"r\") as f:\n    for zeile in f:\n        print(zeile.strip())\n\nHallo Anna\nGuten Morgen Ben\nWillkommen Carla",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arbeiten mit Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/lesen_schreiben.html#alle-zeilen-auf-einmal-lesen-mit-readlines",
    "href": "books/w-python-minimal/skript/lesen_schreiben.html#alle-zeilen-auf-einmal-lesen-mit-readlines",
    "title": "6  Arbeiten mit Dateien",
    "section": "6.4 Alle Zeilen auf einmal lesen mit readlines()",
    "text": "6.4 Alle Zeilen auf einmal lesen mit readlines()\nStatt über eine Datei zu iterieren, können Sie alle Zeilen auf einmal als Liste einlesen:\n\nwith open(\"01-daten/beispiel.txt\", \"r\") as f:\n    zeilen = f.readlines()\n    print(zeilen)\n\n['Dies ist ein Test.']\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nOftmals bestehen die eingelesenen Zeilen aus Werten, die durch ein spezifisches Trennzeichen z.B. “,”. Um diese Zeilen dann in die einzelnen Werte zu trennen, benutzen wir die .split()-Funktion.\n\nzeile = \"319,12,14,190,342\"\nprint(zeile.split(\",\"))\n\n['319', '12', '14', '190', '342']\n\n\nJede Zeile endet mit \\n, deshalb kann eine Nachbearbeitung mit .strip() sinnvoll sein:\n\nfor zeile in zeilen:\n    print(zeile.strip())\n\nDies ist ein Test.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arbeiten mit Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/lesen_schreiben.html#in-eine-datei-schreiben",
    "href": "books/w-python-minimal/skript/lesen_schreiben.html#in-eine-datei-schreiben",
    "title": "6  Arbeiten mit Dateien",
    "section": "6.5 In eine Datei schreiben",
    "text": "6.5 In eine Datei schreiben\n\nwith open(\"ausgabe.txt\", \"w\") as datei:\n    datei.write(\"Das ist eine neue Zeile.\\n\")\n    datei.write(\"Und noch eine.\")\n\n\n\"w\" steht für write (schreiben).\nAchtung: Eine vorhandene Datei wird überschrieben!",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arbeiten mit Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/lesen_schreiben.html#zeilenweise-schreiben-mit-schleife",
    "href": "books/w-python-minimal/skript/lesen_schreiben.html#zeilenweise-schreiben-mit-schleife",
    "title": "6  Arbeiten mit Dateien",
    "section": "6.6 Zeilenweise schreiben mit Schleife",
    "text": "6.6 Zeilenweise schreiben mit Schleife\n\ndaten = [\"Apfel\", \"Banane\", \"Kirsche\"]\n\nwith open(\"obst.txt\", \"w\") as f:\n    for eintrag in daten:\n        f.write(eintrag + \"\\n\")\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nJede Zeile endet mit \\n für einen Zeilenumbruch.\n\n\n\n\n\n\n\n\n\nAufgabe: Liste in Datei schreiben\n\n\n\n\n\nGegeben ist eine Liste von Städten:\nstaedte = [\"Berlin\", \"Hamburg\", \"München\"]\n\nSchreiben Sie ein Programm, das jede Stadt in eine neue Zeile einer Datei staedte.txt schreibt.\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nstaedte = [\"Berlin\", \"Hamburg\", \"München\"]\n\nwith open(\"staedte.txt\", \"w\") as f:\n    for stadt in staedte:\n        f.write(stadt + \"\\n\")",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arbeiten mit Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/lesen_schreiben.html#dateien-manuell-schließen-mit-close",
    "href": "books/w-python-minimal/skript/lesen_schreiben.html#dateien-manuell-schließen-mit-close",
    "title": "6  Arbeiten mit Dateien",
    "section": "6.7 Dateien manuell schließen mit close()",
    "text": "6.7 Dateien manuell schließen mit close()\nWenn Sie keinen with-Block verwenden, müssen Sie die Datei selbst schließen – sonst bleibt sie geöffnet:\n\ndatei = open(\"01-daten/beispiel.txt\", \"w\")\ndatei.write(\"Dies ist ein Test.\")\ndatei.close()\n\n\n\n\n\n\n\nImportant\n\n\n\n\n\nclose() ist wichtig, damit Änderungen gespeichert werden und die Datei nicht gesperrt bleibt.\nEmpfehlung: Nutzen Sie immer with open(...), da Python die Datei dann automatisch schließt – auch bei Fehlern.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Arbeiten mit Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html",
    "href": "books/w-python-minimal/skript/assessment.html",
    "title": "7  Lernzielkontrolle",
    "section": "",
    "text": "7.1 Aufgabe 1: Datentypen und Typecasting\nGegeben sind folgende Werte:\nGib mit type() den Datentyp jedes Werts aus und wandle jeden in einen anderen sinnvollen Typ um. Gib die Ergebnisse aus.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-1-datentypen-und-typecasting",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-1-datentypen-und-typecasting",
    "title": "7  Lernzielkontrolle",
    "section": "",
    "text": "wert1 = \"42\"\nwert2 = 3.5\nwert3 = True",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-2-altersprüfung-mit-bedingung",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-2-altersprüfung-mit-bedingung",
    "title": "7  Lernzielkontrolle",
    "section": "7.2 Aufgabe 2: Altersprüfung mit Bedingung",
    "text": "7.2 Aufgabe 2: Altersprüfung mit Bedingung\nGegeben sei alter = 16.\nGib abhängig vom Alter aus:\n\n„Volljährig“, wenn das Alter ≥ 18 ist\n„Minderjährig“, wenn das Alter &lt; 18 ist",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-3-zahlen-filtern-und-mitteln",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-3-zahlen-filtern-und-mitteln",
    "title": "7  Lernzielkontrolle",
    "section": "7.3 Aufgabe 3: Zahlen filtern und mitteln",
    "text": "7.3 Aufgabe 3: Zahlen filtern und mitteln\nGegeben sei die Liste:\nzahlen = [5, 8, 13, 20, 33, 40]\n\nGib alle Zahlen &gt; 10 aus.\nBerechne und gib den Durchschnitt dieser Zahlen aus.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-4-wochentage-slicing",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-4-wochentage-slicing",
    "title": "7  Lernzielkontrolle",
    "section": "7.4 Aufgabe 4: Wochentage & Slicing",
    "text": "7.4 Aufgabe 4: Wochentage & Slicing\nGegeben sei:\ntage = [\"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\", \"So\"]\n\nGib alle Wochentage aus, die mit „S“ beginnen.\nGib nur die Arbeitstage (Mo–Fr) mit Slicing aus.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-5-funktion-mit-parameter-standardwert",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-5-funktion-mit-parameter-standardwert",
    "title": "7  Lernzielkontrolle",
    "section": "7.5 Aufgabe 5: Funktion mit Parameter & Standardwert",
    "text": "7.5 Aufgabe 5: Funktion mit Parameter & Standardwert\nErstelle eine Funktion begruesse(name, sprache=\"de\"), die je nach Sprache Folgendes ausgibt:\n\nDeutsch: „Hallo !“\nEnglisch: „Hello !“",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-6-hobbys-in-datei-schreiben",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-6-hobbys-in-datei-schreiben",
    "title": "7  Lernzielkontrolle",
    "section": "7.6 Aufgabe 6: Hobbys in Datei schreiben",
    "text": "7.6 Aufgabe 6: Hobbys in Datei schreiben\nGegeben sei eine Liste hobbys = [\"Lesen\", \"Kochen\", \"Sport\"].\nSchreibe jeden Eintrag in eine neue Zeile der Datei hobbys.txt.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-7-datei-lesen-.split-verwenden",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-7-datei-lesen-.split-verwenden",
    "title": "7  Lernzielkontrolle",
    "section": "7.7 Aufgabe 7: Datei lesen & .split() verwenden",
    "text": "7.7 Aufgabe 7: Datei lesen & .split() verwenden\nAngenommen, eine Datei enthält die Zeile:\nAli,Bente,Carlos,Dana\n\nZerlege die Zeichenkette mit .split(\",\").\nGib jeden Namen einzeln aus.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-8-namen-sortieren-und-speichern",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-8-namen-sortieren-und-speichern",
    "title": "7  Lernzielkontrolle",
    "section": "7.8 Aufgabe 8: Namen sortieren und speichern",
    "text": "7.8 Aufgabe 8: Namen sortieren und speichern\nGegeben sei:\nnamen = [\"Zoe\", \"Anna\", \"Lukas\", \"Ben\"]\n\nSortiere die Liste alphabetisch.\nSpeichere die sortierte Liste in eine Datei sortiert.txt, ein Name pro Zeile.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-9-zahlen-durch-3-ausgeben",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-9-zahlen-durch-3-ausgeben",
    "title": "7  Lernzielkontrolle",
    "section": "7.9 Aufgabe 9: Zahlen durch 3 ausgeben",
    "text": "7.9 Aufgabe 9: Zahlen durch 3 ausgeben\nErstelle mit einer Schleife eine Liste aller Zahlen zwischen 1 und 20, die durch 3 teilbar sind, und gib sie aus.",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-minimal/skript/assessment.html#aufgabe-10-verschachtelte-schleifen",
    "href": "books/w-python-minimal/skript/assessment.html#aufgabe-10-verschachtelte-schleifen",
    "title": "7  Lernzielkontrolle",
    "section": "7.10 Aufgabe 10: Verschachtelte Schleifen",
    "text": "7.10 Aufgabe 10: Verschachtelte Schleifen\nGegeben seien:\npersonen = [\"Ali\", \"Bente\"]\nhobbys = [\"Lesen\", \"Sport\"]\nErstelle eine Ausgabe wie:\nAli hat das Hobby: Lesen\nAli hat das Hobby: Sport\nBente hat das Hobby: Lesen\nBente hat das Hobby: Sport",
    "crumbs": [
      "Grundlagen Python",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/index.html",
    "href": "books/w-python-matplotlib/index.html",
    "title": "Matplotlib",
    "section": "",
    "text": "Intro",
    "crumbs": [
      "Matplotlib"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/index.html#voraussetzungen",
    "href": "books/w-python-matplotlib/index.html#voraussetzungen",
    "title": "Matplotlib",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\n\nGrundlagen Python\nEinbinden von zusätzlichen Paketen",
    "crumbs": [
      "Matplotlib"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/index.html#verwendete-pakete-und-datensätze",
    "href": "books/w-python-matplotlib/index.html#verwendete-pakete-und-datensätze",
    "title": "Matplotlib",
    "section": "Verwendete Pakete und Datensätze",
    "text": "Verwendete Pakete und Datensätze\n\nmatplotlib",
    "crumbs": [
      "Matplotlib"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/index.html#bearbeitungszeit",
    "href": "books/w-python-matplotlib/index.html#bearbeitungszeit",
    "title": "Matplotlib",
    "section": "Bearbeitungszeit",
    "text": "Bearbeitungszeit\nGeschätzte Bearbeitungszeit: 1h",
    "crumbs": [
      "Matplotlib"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/index.html#lernziele",
    "href": "books/w-python-matplotlib/index.html#lernziele",
    "title": "Matplotlib",
    "section": "Lernziele",
    "text": "Lernziele\n\nEinleitung: wie visualisiere ich Daten in Python\nAnpassen von Plots\nDo’s & Dont’s für wissenschaftliche Plots",
    "crumbs": [
      "Matplotlib"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/introduction.html",
    "href": "books/w-python-matplotlib/skript/introduction.html",
    "title": "8  Einführung",
    "section": "",
    "text": "8.1 Warum Matplotlib?\nMatplotlib ist eine der bekanntesten Bibliotheken zur Datenvisualisierung in Python. Sie ermöglicht das Erstellen statischer, animierter und interaktiver Diagramme mit hoher Flexibilität.",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/introduction.html#warum-matplotlib",
    "href": "books/w-python-matplotlib/skript/introduction.html#warum-matplotlib",
    "title": "8  Einführung",
    "section": "",
    "text": "Breite Unterstützung: Funktioniert mit NumPy, Pandas und SciPy.\nHohe Anpassbarkeit: Vollständige Kontrolle über Diagramme.\nIntegration in Jupyter Notebooks: Ideal für interaktive Datenanalyse.\nKompatibilität: Unterstützt verschiedene Ausgabeformate (PNG, SVG, PDF etc.).",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/introduction.html#alternativen-zu-matplotlib",
    "href": "books/w-python-matplotlib/skript/introduction.html#alternativen-zu-matplotlib",
    "title": "8  Einführung",
    "section": "8.2 Alternativen zu Matplotlib",
    "text": "8.2 Alternativen zu Matplotlib\nWährend Matplotlib leistungsstark ist, gibt es Alternativen, die für bestimmte Zwecke besser geeignet sein können: - Seaborn: Basiert auf Matplotlib, erleichtert statistische Visualisierung. - Plotly: Erzeugt interaktive Plots, gut für Dashboards. - Bokeh: Ideal für Web-Anwendungen mit interaktiven Visualisierungen.",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/introduction.html#erstes-beispiel-einfache-linie-plotten",
    "href": "books/w-python-matplotlib/skript/introduction.html#erstes-beispiel-einfache-linie-plotten",
    "title": "8  Einführung",
    "section": "8.3 Erstes Beispiel: Einfache Linie plotten",
    "text": "8.3 Erstes Beispiel: Einfache Linie plotten\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Beispiel-Daten\nt = np.linspace(0, 10, 100)\ny = np.sin(t)\n\n# Erstellen des Plots\nplt.plot(t, y, label='sin(t)')\nplt.xlabel('Zeit (s)')\nplt.ylabel('Amplitude')\nplt.title('Einfaches Linien-Diagramm')\nplt.legend()\nplt.show()\nDieses einfache Beispiel zeigt, wie man mit Matplotlib eine Sinuskurve visualisieren kann.",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/introduction.html#nächste-schritte",
    "href": "books/w-python-matplotlib/skript/introduction.html#nächste-schritte",
    "title": "8  Einführung",
    "section": "8.4 Nächste Schritte",
    "text": "8.4 Nächste Schritte\nIm nächsten Kapitel werden wir uns mit den verschiedenen Diagrammtypen beschäftigen, die Matplotlib bietet.",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Einführung</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/basic_plot_types.html",
    "href": "books/w-python-matplotlib/skript/basic_plot_types.html",
    "title": "9  Diagrammtypen in Matplotlib",
    "section": "",
    "text": "9.1 1. Liniendiagramme (plt.plot())\nMatplotlib bietet eine Vielzahl von Diagrammtypen, die für unterschiedliche Zwecke geeignet sind. In diesem Kapitel werden die wichtigsten Diagrammtypen vorgestellt und ihre Anwendungsfälle erklärt.\nLiniendiagramme eignen sich hervorragend zur Darstellung von Trends über Zeit.\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 10, 100)\ny = np.sin(t)\n\nplt.plot(t, y, label='sin(t)', color='b')\nplt.xlabel('Zeit (s)')\nplt.ylabel('Amplitude')\nplt.title('Liniendiagramm')\nplt.legend()\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Diagrammtypen in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/basic_plot_types.html#streudiagramme-plt.scatter",
    "href": "books/w-python-matplotlib/skript/basic_plot_types.html#streudiagramme-plt.scatter",
    "title": "9  Diagrammtypen in Matplotlib",
    "section": "9.2 2. Streudiagramme (plt.scatter())",
    "text": "9.2 2. Streudiagramme (plt.scatter())\nStreudiagramme werden verwendet, um Zusammenhänge zwischen zwei Variablen darzustellen.\n\nx = np.random.rand(50)\ny = np.random.rand(50)\n\nplt.scatter(x, y, color='r', alpha=0.5)\nplt.xlabel('Variable X')\nplt.ylabel('Variable Y')\nplt.title('Streudiagramm')\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Diagrammtypen in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/basic_plot_types.html#balkendiagramme-plt.bar",
    "href": "books/w-python-matplotlib/skript/basic_plot_types.html#balkendiagramme-plt.bar",
    "title": "9  Diagrammtypen in Matplotlib",
    "section": "9.3 3. Balkendiagramme (plt.bar())",
    "text": "9.3 3. Balkendiagramme (plt.bar())\nBalkendiagramme eignen sich zur Darstellung kategorialer Daten.\n\nkategorien = ['A', 'B', 'C', 'D']\nwerte = [3, 7, 1, 5]\n\nplt.bar(kategorien, werte, color='g')\nplt.xlabel('Kategorien')\nplt.ylabel('Wert')\nplt.title('Balkendiagramm')\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Diagrammtypen in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/basic_plot_types.html#histogramme-plt.hist",
    "href": "books/w-python-matplotlib/skript/basic_plot_types.html#histogramme-plt.hist",
    "title": "9  Diagrammtypen in Matplotlib",
    "section": "9.4 4. Histogramme (plt.hist())",
    "text": "9.4 4. Histogramme (plt.hist())\nHistogramme zeigen die Verteilung numerischer Daten.\n\ndaten = np.random.randn(1000)\nplt.hist(daten, bins=30, color='purple', alpha=0.7)\nplt.xlabel('Wert')\nplt.ylabel('Häufigkeit')\nplt.title('Histogramm')\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Diagrammtypen in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/basic_plot_types.html#boxplots-plt.boxplot",
    "href": "books/w-python-matplotlib/skript/basic_plot_types.html#boxplots-plt.boxplot",
    "title": "9  Diagrammtypen in Matplotlib",
    "section": "9.5 5. Boxplots (plt.boxplot())",
    "text": "9.5 5. Boxplots (plt.boxplot())\nBoxplots helfen, Ausreißer und die Verteilung von Daten zu visualisieren.\n\ndaten = [np.random.randn(100) for _ in range(4)]\nplt.boxplot(daten, labels=['A', 'B', 'C', 'D'])\nplt.ylabel('Wert')\nplt.title('Boxplot')\nplt.show()\n\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_37889/2728911591.py:2: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.\n  plt.boxplot(daten, labels=['A', 'B', 'C', 'D'])",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Diagrammtypen in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/basic_plot_types.html#heatmaps-plt.imshow",
    "href": "books/w-python-matplotlib/skript/basic_plot_types.html#heatmaps-plt.imshow",
    "title": "9  Diagrammtypen in Matplotlib",
    "section": "9.6 6. Heatmaps (plt.imshow())",
    "text": "9.6 6. Heatmaps (plt.imshow())\nHeatmaps eignen sich zur Darstellung von 2D-Daten.\n\ndaten = np.random.rand(10, 10)\nplt.imshow(daten, cmap='coolwarm', interpolation='nearest')\nplt.colorbar()\nplt.title('Heatmap')\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Diagrammtypen in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/basic_plot_types.html#fazit",
    "href": "books/w-python-matplotlib/skript/basic_plot_types.html#fazit",
    "title": "9  Diagrammtypen in Matplotlib",
    "section": "9.7 Fazit",
    "text": "9.7 Fazit\nDie Wahl des richtigen Diagrammtyps hängt von der Art der Daten und der gewünschten Darstellung ab. Im nächsten Kapitel werden wir uns mit der Anpassung und Gestaltung von Plots beschäftigen.",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Diagrammtypen in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/adapting_plots.html",
    "href": "books/w-python-matplotlib/skript/adapting_plots.html",
    "title": "10  Anpassung und Gestaltung von Plots in Matplotlib",
    "section": "",
    "text": "10.1 1. Achsentitel und Diagrammtitel\nEin gut gestaltetes Diagramm verbessert die Lesbarkeit und Verständlichkeit der dargestellten Daten. In diesem Kapitel werden wir verschiedene Möglichkeiten zur Anpassung und Gestaltung von Plots in Matplotlib erkunden.\nKlare Achsen- und Diagrammtitel sind essenziell für die Verständlichkeit eines Plots.\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 10, 100)\ny = np.sin(t)\n\nplt.plot(t, y, label='sin(t)', color='b')\nplt.xlabel('Zeit (s)', fontsize=12)\nplt.ylabel('Amplitude', fontsize=12)\nplt.title('Liniendiagramm mit Beschriftung', fontsize=14)\nplt.legend()\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Anpassung und Gestaltung von Plots in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/adapting_plots.html#anpassung-der-achsen",
    "href": "books/w-python-matplotlib/skript/adapting_plots.html#anpassung-der-achsen",
    "title": "10  Anpassung und Gestaltung von Plots in Matplotlib",
    "section": "10.2 2. Anpassung der Achsen",
    "text": "10.2 2. Anpassung der Achsen\nDie Skalierung der Achsen sollte sinnvoll gewählt werden, um die Daten bestmöglich darzustellen.\n\nplt.plot(t, y, label='sin(t)', color='b')\nplt.xlabel('Zeit (s)')\nplt.ylabel('Amplitude')\nplt.xlim(0, 10)\nplt.ylim(-1.2, 1.2)\nplt.grid(True, linestyle='--', alpha=0.7)\nplt.title('Liniendiagramm mit angepassten Achsen')\nplt.legend()\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Anpassung und Gestaltung von Plots in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/adapting_plots.html#farben-und-linienstile",
    "href": "books/w-python-matplotlib/skript/adapting_plots.html#farben-und-linienstile",
    "title": "10  Anpassung und Gestaltung von Plots in Matplotlib",
    "section": "10.3 3. Farben und Linienstile",
    "text": "10.3 3. Farben und Linienstile\nFarben und Linienstile helfen dabei, wichtige Informationen im Plot hervorzuheben.\n\n10.3.1 Wichtige Farben (Standardfarben in Matplotlib)\n\n\n\nFarbe\nKürzel\nBeschreibung\n\n\n\n\nBlau\n‘b’\nblue\n\n\nGrün\n‘g’\ngreen\n\n\nRot\n‘r’\nred\n\n\nCyan\n‘c’\ncyan\n\n\nMagenta\n‘m’\nmagenta\n\n\nGelb\n‘y’\nyellow\n\n\nSchwarz\n‘k’\nblack\n\n\nWeiß\n‘w’\nwhite\n\n\n\n\n\n10.3.2 Wichtige Linienstile\n\n\n\nLinienstil\nKürzel\nBeschreibung\n\n\n\n\nDurchgezogen\n‘-’\nStandardlinie\n\n\nGestrichelt\n‘–’\nlange Striche\n\n\nGepunktet\n‘:’\nnur Punkte\n\n\nStrich-Punkt\n‘-.’\nabwechselnd Strich-Punkt\n\n\n\n\nplt.plot(t, np.sin(t), linestyle='-', color='r', label='sin(t)')\nplt.plot(t, np.cos(t), linestyle='--', color='g', label='cos(t)')\nplt.xlabel('Zeit (s)')\nplt.ylabel('Amplitude')\nplt.title('Anpassung von Farben und Linienstilen')\nplt.legend()\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Anpassung und Gestaltung von Plots in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/adapting_plots.html#mehrere-plots-mit-subplots",
    "href": "books/w-python-matplotlib/skript/adapting_plots.html#mehrere-plots-mit-subplots",
    "title": "10  Anpassung und Gestaltung von Plots in Matplotlib",
    "section": "10.4 4. Mehrere Plots mit Subplots",
    "text": "10.4 4. Mehrere Plots mit Subplots\nManchmal ist es sinnvoll, mehrere Diagramme in einer Abbildung darzustellen.\n\nfig, axs = plt.subplots(2, 1, figsize=(6, 6))\naxs[0].plot(t, np.sin(t), color='b')\naxs[0].set_title('Sinusfunktion')\naxs[1].plot(t, np.cos(t), color='r')\naxs[1].set_title('Kosinusfunktion')\nplt.tight_layout()\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Anpassung und Gestaltung von Plots in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/adapting_plots.html#speichern-von-plots",
    "href": "books/w-python-matplotlib/skript/adapting_plots.html#speichern-von-plots",
    "title": "10  Anpassung und Gestaltung von Plots in Matplotlib",
    "section": "10.5 5. Speichern von Plots",
    "text": "10.5 5. Speichern von Plots\nMan kann Diagramme in verschiedenen Formaten speichern.\n\nplt.plot(t, y, label='sin(t)', color='b')\nplt.xlabel('Zeit (s)')\nplt.ylabel('Amplitude')\nplt.title('Speicherung eines Plots')\nplt.legend()\nplt.savefig('mein_plot.png', dpi=300)\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Anpassung und Gestaltung von Plots in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/adapting_plots.html#fazit",
    "href": "books/w-python-matplotlib/skript/adapting_plots.html#fazit",
    "title": "10  Anpassung und Gestaltung von Plots in Matplotlib",
    "section": "10.6 Fazit",
    "text": "10.6 Fazit\nDurch geschickte Anpassungen lassen sich wissenschaftliche Plots deutlich verbessern. Im nächsten Kapitel werden wir uns mit erweiterten Techniken wie logarithmischen Skalen und Annotationen beschäftigen.",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Anpassung und Gestaltung von Plots in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/advanced_techniques.html",
    "href": "books/w-python-matplotlib/skript/advanced_techniques.html",
    "title": "11  Erweiterte Techniken in Matplotlib",
    "section": "",
    "text": "11.1 1. Logarithmische Skalen\nIn diesem Kapitel betrachten wir einige fortgeschrittene Funktionen von Matplotlib, die für die wissenschaftliche Datenvisualisierung besonders nützlich sind.\nLogarithmische Skalen werden oft verwendet, wenn Werte große Größenordnungen umfassen.\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.logspace(0.1, 2, 100)\ny = np.log10(x)\n\nplt.plot(x, y, label='log10(x)', color='b')\nplt.xscale('log')\nplt.xlabel('X-Wert (log-Skala)')\nplt.ylabel('Y-Wert')\nplt.title('Logarithmische Skalierung')\nplt.legend()\nplt.grid(True, which='both', linestyle='--', alpha=0.7)\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Erweiterte Techniken in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/advanced_techniques.html#twin-achsen-für-verschiedene-skalierungen",
    "href": "books/w-python-matplotlib/skript/advanced_techniques.html#twin-achsen-für-verschiedene-skalierungen",
    "title": "11  Erweiterte Techniken in Matplotlib",
    "section": "11.2 2. Twin-Achsen für verschiedene Skalierungen",
    "text": "11.2 2. Twin-Achsen für verschiedene Skalierungen\nManchmal möchte man zwei verschiedene y-Achsen in einem Plot darstellen.\n\nx = np.linspace(0, 10, 100)\ny1 = np.sin(x)\ny2 = np.exp(x / 3)\n\nfig, ax1 = plt.subplots()\nax2 = ax1.twinx()\nax1.plot(x, y1, 'g-', label='sin(x)')\nax2.plot(x, y2, 'b--', label='exp(x/3)')\n\nax1.set_xlabel('X-Wert')\nax1.set_ylabel('Sinus', color='g')\nax2.set_ylabel('Exponentiell', color='b')\nax1.set_title('Twin-Achsen für unterschiedliche Skalierungen')\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Erweiterte Techniken in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/advanced_techniques.html#annotationen-in-diagrammen",
    "href": "books/w-python-matplotlib/skript/advanced_techniques.html#annotationen-in-diagrammen",
    "title": "11  Erweiterte Techniken in Matplotlib",
    "section": "11.3 3. Annotationen in Diagrammen",
    "text": "11.3 3. Annotationen in Diagrammen\nWichtige Punkte oder Werte in einem Diagramm können mit Annotationen hervorgehoben werden.\n\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\nplt.plot(x, y, label='sin(x)')\nplt.xlabel('X-Wert')\nplt.ylabel('Amplitude')\nplt.title('Annotationen in Matplotlib')\nplt.annotate('Maximalwert', xy=(np.pi/2, 1), xytext=(2, 1.2),\n             arrowprops=dict(facecolor='red', shrink=0.05))\nplt.legend()\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Erweiterte Techniken in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/advanced_techniques.html#fazit",
    "href": "books/w-python-matplotlib/skript/advanced_techniques.html#fazit",
    "title": "11  Erweiterte Techniken in Matplotlib",
    "section": "11.4 Fazit",
    "text": "11.4 Fazit\nDiese erweiterten Funktionen helfen dabei, wissenschaftliche Plots noch informativer zu gestalten. Im nächsten Kapitel werden wir Best Practices und typische Fehler in der wissenschaftlichen Visualisierung betrachten.",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Erweiterte Techniken in Matplotlib</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/scientific_plotting.html",
    "href": "books/w-python-matplotlib/skript/scientific_plotting.html",
    "title": "12  Best Practices in Matplotlib: Fehler und Verbesserungen",
    "section": "",
    "text": "12.1 1. Fehlende Beschriftungen\nIn diesem Kapitel zeigen wir für häufige Problemstellungen jeweils ein schlechtes und ein verbessertes Beispiel.",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Best Practices in Matplotlib: Fehler und Verbesserungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/scientific_plotting.html#fehlende-beschriftungen",
    "href": "books/w-python-matplotlib/skript/scientific_plotting.html#fehlende-beschriftungen",
    "title": "12  Best Practices in Matplotlib: Fehler und Verbesserungen",
    "section": "",
    "text": "12.1.1 ❌ Schlechtes Beispiel\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\nplt.plot(x, y)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n12.1.2 ✅ Besseres Beispiel\n\nplt.plot(x, y, label='sin(x)', color='b')\nplt.xlabel('Zeit (s)')\nplt.ylabel('Amplitude')\nplt.title('Sinuskurve')\nplt.legend()\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Best Practices in Matplotlib: Fehler und Verbesserungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/scientific_plotting.html#ungünstige-farbwahl",
    "href": "books/w-python-matplotlib/skript/scientific_plotting.html#ungünstige-farbwahl",
    "title": "12  Best Practices in Matplotlib: Fehler und Verbesserungen",
    "section": "12.2 2. Ungünstige Farbwahl",
    "text": "12.2 2. Ungünstige Farbwahl\n\n12.2.1 ❌ Schlechtes Beispiel\n\nplt.plot(x, y, color='yellow')\nplt.show()\n\n\n\n\n\n\n\n\n\n\n12.2.2 ✅ Besseres Beispiel\n\nplt.plot(x, y, color='darkblue')\nplt.grid(True, linestyle='--', alpha=0.7)\nplt.title('Gute Kontraste für bessere Lesbarkeit')\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Best Practices in Matplotlib: Fehler und Verbesserungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/scientific_plotting.html#keine-sinnvolle-achsenskalierung",
    "href": "books/w-python-matplotlib/skript/scientific_plotting.html#keine-sinnvolle-achsenskalierung",
    "title": "12  Best Practices in Matplotlib: Fehler und Verbesserungen",
    "section": "12.3 3. Keine sinnvolle Achsenskalierung",
    "text": "12.3 3. Keine sinnvolle Achsenskalierung\n\n12.3.1 ❌ Schlechtes Beispiel\n\nplt.plot(x, y)\nplt.ylim(0.5, 1)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n12.3.2 ✅ Besseres Beispiel\n\nplt.plot(x, y)\nplt.ylim(-1.2, 1.2)\nplt.xlim(0, 10)\nplt.grid(True)\nplt.title('Sinnvolle Achsenskalierung')\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Best Practices in Matplotlib: Fehler und Verbesserungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/scientific_plotting.html#überladung-durch-zu-viele-linien",
    "href": "books/w-python-matplotlib/skript/scientific_plotting.html#überladung-durch-zu-viele-linien",
    "title": "12  Best Practices in Matplotlib: Fehler und Verbesserungen",
    "section": "12.4 4. Überladung durch zu viele Linien",
    "text": "12.4 4. Überladung durch zu viele Linien\n\n12.4.1 ❌ Schlechtes Beispiel\n\nfor i in range(10):\n    plt.plot(x, np.sin(x + i * 0.2))\nplt.show()\n\n\n\n\n\n\n\n\n\n\n12.4.2 ✅ Besseres Beispiel\n\nplt.plot(x, np.sin(x), label='sin(x)')\nplt.plot(x, np.cos(x), label='cos(x)')\nplt.legend()\nplt.title('Weniger ist mehr: Reduzierte Informationsdichte')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Best Practices in Matplotlib: Fehler und Verbesserungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-matplotlib/skript/scientific_plotting.html#fazit",
    "href": "books/w-python-matplotlib/skript/scientific_plotting.html#fazit",
    "title": "12  Best Practices in Matplotlib: Fehler und Verbesserungen",
    "section": "12.5 Fazit",
    "text": "12.5 Fazit\nGute Plots zeichnen sich durch klare Beschriftungen, gute Lesbarkeit und eine sinnvolle Informationsdichte aus.",
    "crumbs": [
      "Matplotlib",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Best Practices in Matplotlib: Fehler und Verbesserungen</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/index.html",
    "href": "books/w-python-numpy-grundlagen/index.html",
    "title": "Numpy",
    "section": "",
    "text": "Intro",
    "crumbs": [
      "Numpy"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/index.html#voraussetzungen",
    "href": "books/w-python-numpy-grundlagen/index.html#voraussetzungen",
    "title": "Numpy",
    "section": "Voraussetzungen",
    "text": "Voraussetzungen\n\nGrundlagen Python\nEinbinden von zusätzlichen Paketen\nPlotten mit Matplotlib",
    "crumbs": [
      "Numpy"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/index.html#verwendete-pakete-und-datensätze",
    "href": "books/w-python-numpy-grundlagen/index.html#verwendete-pakete-und-datensätze",
    "title": "Numpy",
    "section": "Verwendete Pakete und Datensätze",
    "text": "Verwendete Pakete und Datensätze\n\nPakete\n\nNumPy\nMatplotlib\n\n\n\nDatensätze\n\nTC01.csv\nBild: Mona Lisa\nBild: Campus",
    "crumbs": [
      "Numpy"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/index.html#bearbeitungszeit",
    "href": "books/w-python-numpy-grundlagen/index.html#bearbeitungszeit",
    "title": "Numpy",
    "section": "Bearbeitungszeit",
    "text": "Bearbeitungszeit\nGeschätzte Bearbeitungszeit: 2h",
    "crumbs": [
      "Numpy"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/index.html#lernziele",
    "href": "books/w-python-numpy-grundlagen/index.html#lernziele",
    "title": "Numpy",
    "section": "Lernziele",
    "text": "Lernziele\n\nEinleitung: was ist NumPy, Vor- und Nachteile\nNutzen des NumPy-Moduls\nErstellen von NumPy-Arrays\nSlicing\nLesen und schreiben von Dateien\nArbeiten mit Bildern",
    "crumbs": [
      "Numpy"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/introduction.html",
    "href": "books/w-python-numpy-grundlagen/skript/introduction.html",
    "title": "13  Einführung NumPy",
    "section": "",
    "text": "13.1 Vorteile & Nachteile\nNumPy ist eine leistungsstarke Bibliothek für Python, die für numerisches Rechnen und Datenanalyse verwendet wird. Daher auch der Name NumPy, ein Akronym für “Numerisches Python” (englisch: “Numeric Python” oder “Numerical Python”). NumPy selbst ist hauptsächlich in der Programmiersprache C geschrieben, weshalb NumPy generell sehr schnell ist.\nNumPy bietet ein effizientes Arbeiten mit kleinen und großen Vektoren und Matrizen, die so ansonsten nur umständlich in nativem Python implementiert werden würden. Dabei bietet NumPy auch die Möglichkeit, einfach mit Vektoren und Matrizen zu rechnen, und das auch für sehr große Datenmengen.\nDiese Einführung wird Ihnen dabei helfen, die Grundlagen von NumPy zu verstehen und zu nutzen.\nFast immer sind Operationen mit Numpy Datenstrukturen schneller. Im Gegensatz zu nativen Python Listen kann man dort aber nur einen Datentyp pro Liste speichern.",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Einführung NumPy</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/introduction.html#vorteile-nachteile",
    "href": "books/w-python-numpy-grundlagen/skript/introduction.html#vorteile-nachteile",
    "title": "13  Einführung NumPy",
    "section": "",
    "text": "Warum ist numpy oftmals schneller?\n\n\n\n\n\nNumPy implementiert eine effizientere Speicherung von Listen im Speicher. Nativ speichert Python Listeninhalte aufgeteilt, wo gerade Platz ist.\n\n\n\n\n\n\nFigure 13.1: Speicherung von Daten in nativem Python\n\n\n\nDagegen werden NumPy Arrays und Matritzen zusammenhängend gespeichert, was einen effizienteren Datenaufruf ermöglicht.\n\n\n\n\n\n\nFigure 13.2: Speicherung von Daten bei Numpy\n\n\n\nDies bedeutet aber auch, dass es eine Erweiterung der Liste deutlich schneller ist als eine Erweiterung von Arrays oder Matrizen. Bei Listen kann jeder freie Platz genutzt werden, während Arrays und Matrizen an einen neuen Ort im Speicher kopiert werden müssen.",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Einführung NumPy</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/introduction.html#einbinden-des-pakets",
    "href": "books/w-python-numpy-grundlagen/skript/introduction.html#einbinden-des-pakets",
    "title": "13  Einführung NumPy",
    "section": "13.2 Einbinden des Pakets",
    "text": "13.2 Einbinden des Pakets\nNumPy wird über folgende Zeile eingebunden. Dabei hat sich global der Standard entwickelt, als Alias np zu verwenden.\n\nimport numpy as np",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Einführung NumPy</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/introduction.html#referenzen",
    "href": "books/w-python-numpy-grundlagen/skript/introduction.html#referenzen",
    "title": "13  Einführung NumPy",
    "section": "13.3 Referenzen",
    "text": "13.3 Referenzen\nSämtliche hier vorgestellten Funktionen lassen sich in der (englischen) NumPy-Dokumentation nachschlagen: Dokumentation",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Einführung NumPy</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_creation.html",
    "href": "books/w-python-numpy-grundlagen/skript/array_creation.html",
    "title": "14  Erstellen von NumPy arrays",
    "section": "",
    "text": "Typischerweise werden in Python Vektoren durch Listen und Matrizen durch geschachtelte Listen ausgedrückt. Beispielsweise würde man den Vektor\n\n\n\n\\[\n(1, 2, 3, 4, 5, 6)\n\\]\n\n\nund die Matrix\n\n\n\\[\n\\begin{pmatrix}\n1 & 2 & 3\\\\\n4 & 5 & 6\n\\end{pmatrix}\n\\]\n\n\n\nnativ in Python so erstellen:\n\nliste = [1, 2, 3, 4, 5, 6]\n\nmatrix = [[1, 2, 3], [4, 5, 6]]\n\nprint(liste)\nprint(matrix)\n\n[1, 2, 3, 4, 5, 6]\n[[1, 2, 3], [4, 5, 6]]\n\n\nMöchte man jetzt NumPy Arrays verwenden benutzt man den Befehl np.array().\n\nliste = np.array([1, 2, 3, 4, 5, 6])\n\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n\nprint(liste)\nprint(matrix)\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\nBetrachtet man die Ausgaben der print() Befehle fallen zwei Sachen auf. Zum einen fallen die Kommata weg und zum anderen wird die Matrix passend ausgegeben.\nEs gibt auch die Möglichkeit, höherdimensionale Arrays zu erstellen. Dabei wird eine neue Ebene der Verschachtelung benutzt. Im folgenden Beispiel wird eine drei-dimensionale Matrix erstellt.\n\nmatrix_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\n\nEs gilt als “good practice” Arrays immer zu initialisieren. Dafür bietet NumPy drei Funktionen um vorinitialisierte Arrays zu erzeugen. Alternativ können Arrays auch mit festgesetzten Werten initialisiert werden. Dafür kann entweder die Funktion np.zeros()verwendet werden die alle Werte auf 0 setzt, oder aber np.ones()welche alle Werte mit 1 initialisiert. Der Funktion wird die Form im Format [Reihen,Spalten] übergeben. Möchte man alle Einträge auf einen spezifischen Wert setzen, kann man den Befehl np.full() benutzen.\n\nnp.zeros([2,3])\n\narray([[0., 0., 0.],\n       [0., 0., 0.]])\n\n\n\nnp.ones([2,3])\n\narray([[1., 1., 1.],\n       [1., 1., 1.]])\n\n\n\nnp.full([2,3],7)\n\narray([[7, 7, 7],\n       [7, 7, 7]])\n\n\n\n\n\n\n\n\nWie könnte man auch Arrays die mit einer Zahl x gefühlt sind erstellen?\n\n\n\n\n\nDer Trick beseht hierbei ein Array mit np.ones() zu initialisiere und dieses Array dann mit der Zahl x zu multiplizieren. Im folgenden Beispiel ist x = 5\n\nnp.ones([2,3]) * 5\n\narray([[5., 5., 5.],\n       [5., 5., 5.]])\n\n\n\n\n\nMöchte man zum Beispiel für eine Achse in einem Plot einen Vektor mit gleichmäßig verteilten Werten erstellen, bieten sich in NumPy zwei Möglichkeiten. Mit den Befehlen np.linspace(Start,Stop,#Anzahl Werte) und np.arrange(Start,Stop,Abstand zwischen Werten) können solche Arrays erstellt werden.\n\nnp.linspace(0,1,11)\n\narray([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1. ])\n\n\n\nnp.arange(0,10,2)\n\narray([0, 2, 4, 6, 8])\n\n\n\n\n\n\n\n\nZwischenübung: Array Erstellung\n\n\n\n\n\nErstellen Sie jeweils ein NumPy-Array, mit dem folgenden Inhalt:\n\nmit den Werten 1, 7, 42, 99\nzehn mal die Zahl 5\nmit den Zahlen von 35 bis einschließlich 50\nmit allen geraden Zahlen von 20 bis einschließlich 40\neine Matrix mit 5 Spalten und 4 Reihen mit dem Wert 4 an jeder Stelle\nmit 10 Werten die gleichmäßig zwischen 22 und einschlieslich 40 verteilt sind\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\n# 1. \nprint(np.array([1, 7, 42, 99]))\n\n[ 1  7 42 99]\n\n\n\n# 2. \nprint(np.full(10,5))\n\n[5 5 5 5 5 5 5 5 5 5]\n\n\n\n# 3. \nprint(np.arange(35, 51))\n\n[35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50]\n\n\n\n# 4. \nprint(np.arange(20, 41, 2))\n\n[20 22 24 26 28 30 32 34 36 38 40]\n\n\n\n# 5. \nprint(np.full([4,5],4))\n\n[[4 4 4 4 4]\n [4 4 4 4 4]\n [4 4 4 4 4]\n [4 4 4 4 4]]\n\n\n\n# 6. \nprint(np.linspace(22, 40, 10))\n\n[22. 24. 26. 28. 30. 32. 34. 36. 38. 40.]",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Erstellen von NumPy arrays</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_info.html",
    "href": "books/w-python-numpy-grundlagen/skript/array_info.html",
    "title": "15  Größe, Struktur und Typ",
    "section": "",
    "text": "Wenn man sich nicht mehr sicher ist, welche Struktur oder Form ein Array hat oder oder diese Größen zum Beispiel für Schleifen nutzen möchte, bietet NumPy folgende Funktionen für das Auslesen dieser Größen an.\n\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n\nnp.shape() gibt die Längen der einzelnen Dimension in Form einer Liste zurück.\n\nnp.shape(matrix)\n\n(2, 3)\n\n\nDie native Python Funktion len() gibt dagegen nur die Länge der ersten Dimension, also die Anzahl der Elemente in den äußeren Klammern wieder. Im obrigen Beispiel würde len() also die beiden Listen [1, 2, 3] und [4, 5, 6] sehen.\n\nlen(matrix)\n\n2\n\n\nDie Funktion np.ndm() gibt im Gegensatz zu np.shape() nur die Anzahl der Dimensionen zurück.\n\nnp.ndim(matrix)\n\n2\n\n\n\n\n\n\n\n\nDie Ausgabe von np.ndim() kann mit np.shape()und einer nativen Python Funktion erreicht werden. Wie?\n\n\n\n\n\nnp.ndim() gibt die Länge der Liste von np.shape() aus\n\nlen(np.shape(matrix))\n\n2\n\n\n\n\n\nMöchte man die Anzahl aller Elemente in einem Array ausgeben kann man die Funktion np.size() benutzen.\n\nnp.size(matrix)\n\n6\n\n\nNumPy Arrays können verschiedene Datentypen beinhalten. Im folgenden haben wir drei verschiedene Arrays mit einem jeweils anderen Datentyp.\n\ntyp_a = np.array([1, 2, 3, 4, 5])\ntyp_b = np.array([0.1, 0.2, 0.3, 0.4, 0.5])\ntyp_c = np.array([\"Montag\", \"Dienstag\", \"Mittwoch\"])\n\nMit der Methode np.dtype können wir den Datentyp von Arrays ausgeben lassen. Meist wird dabei der Typ plus eine Zahl ausgegeben, welche die zum Speichern benötigte Bytezahl angibt. Das Array typ_a beinhaltet den Datentyp int64, also ganze Zahlen.\n\nprint(typ_a.dtype)\n\nint64\n\n\nDas Array typ_b beinhaltet den Datentyp float64, wobei float für Gleitkommazahlen steht.\n\nprint(typ_b.dtype)\n\nfloat64\n\n\nDas Array typ_c beinhaltet den Datentyp U8, wobei das U für Unicode steht. Hier wird als Unicodetext gespeichert.\n\nprint(typ_c.dtype)\n\n&lt;U8\n\n\nIm folgenden finden Sie eine Tabelle mit den typischen Datentypen, die sie häufig antreffen.\n\n\n\nTable 15.1: Typische Datentypen in NumPy\n\n\n\n\n\nDatentyp\nNumpy Name\nBeispiele\n\n\n\n\nWahrheitswert\nbool\n[True, False, True]\n\n\nGanze Zahl\nint\n[-2, 5, -6, 7, 3]\n\n\npositive Ganze Zahlen\nuint\n[1, 2, 3, 4, 5]\n\n\nKommazahlen\nfloat\n[1.3, 7.4, 3.5, 5.5]\n\n\nkomplexe zahlen\ncomplex\n[-1 + 9j, 2-77j, 72 + 11j]\n\n\nTextzeichen\nU\n[“montag”, “dienstag”]\n\n\n\n\n\n\n\n\n\n\n\n\nZwischenübung: Arrayinformationen auslesen\n\n\n\n\n\nGegeben sei folgende Matrix:\n\nmatrix = np.array([[[ 0,  1,  2,  3],\n                 [ 4,  5,  6,  7],\n                 [ 8,  9, 10, 11]],\n\n                [[12, 13, 14, 15],\n                 [16, 17, 18, 19],\n                 [20, 21, 22, 23]],\n\n                [[24, 25, 26, 27],\n                 [28, 29, 30, 31],\n                 [32, 33, 34, 35]]])\n\nBestimmen Sie durch anschauen die Anzahl an Dimensionen und die Länge jeder Dimension. Von welchem Typ ist der Inhalt dieser Matrix?\nÜberprüfen Sie daraufhin Ihre Ergebnisse in dem Sie die passenden NumPy-Funktionen anwenden.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nmatrix = np.array([[[ 0,  1,  2,  3],\n                 [ 4,  5,  6,  7],\n                 [ 8,  9, 10, 11]],\n\n                [[12, 13, 14, 15],\n                 [16, 17, 18, 19],\n                 [20, 21, 22, 23]],\n\n                [[24, 25, 26, 27],\n                 [28, 29, 30, 31],\n                 [32, 33, 34, 35]]])\n\nanzahl_dimensionen = np.ndim(matrix)\n\nprint(\"Anzahl unterschiedlicher Dimensionen: \", anzahl_dimensionen)\n\nlaenge_dimensionen = np.shape(matrix)\n\nprint(\"Länge der einzelnen DImensionen: \", laenge_dimensionen)\n\nprint(matrix.dtype)\n\nAnzahl unterschiedlicher Dimensionen:  3\nLänge der einzelnen DImensionen:  (3, 3, 4)\nint64",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Größe, Struktur und Typ</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_calculation.html",
    "href": "books/w-python-numpy-grundlagen/skript/array_calculation.html",
    "title": "16  Rechnen mit Arrays",
    "section": "",
    "text": "16.1 Arithmetische Funktionen\nEin großer Vorteil an NumPy ist das Rechnen mit Arrays. Ohne NumPy müsste man entweder eine Schleife oder aber List comprehension benutzen, um mit sämtlichen Werten in der Liste zu rechnen. In NumPy fällt diese Unannehmlichkeit weg.\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 8, 7, 6, 5])\nNormale mathematische Operationen, wie die Addition, lassen sich auf zwei Arten ausdrücken. Entweder über die np.add() Funktion oder aber simpel über das + Zeichen.\nnp.add(a,b)\n\narray([10, 10, 10, 10, 10])\na + b\n\narray([10, 10, 10, 10, 10])\nOhne NumPy würde die Operation folgendermaßen aussehen:\nergebnis = np.ones(5)\nfor i in range(len(a)):\n    ergebnis[i] = a[i] + b[i]\n\nprint(ergebnis)\n\n[10. 10. 10. 10. 10.]\nFür die anderen Rechenarten existieren auch Funktionen: np.subtract(), np.multiply() und np.divide().\nAuch für die anderen höheren Rechenoperationen gibt es ebenfalls Funktionen:",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Rechnen mit Arrays</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_calculation.html#arithmetische-funktionen",
    "href": "books/w-python-numpy-grundlagen/skript/array_calculation.html#arithmetische-funktionen",
    "title": "16  Rechnen mit Arrays",
    "section": "",
    "text": "np.exp(a)\nnp.sqrt(a)\nnp.power(a, 3)\nnp.sin(a)\nnp.cos(a)\nnp.tan(a)\nnp.log(a)\na.dot(b)\n\n\n\n\n\n\n\nArbeiten mit Winkelfunktionen\n\n\n\nWie auch am Taschenrechner birgt das Arbeiten mit den Winkelfunktionen (sin, cos, …) die Fehlerquelle, dass man nicht mit Radian-Werten, sondern mit Grad-Werten arbeitet. Die Winkelfunktionen in numpy erwarten jedoch Radian-Werte.\nFür eine einfache Umrechnung bietet NumPy die Funktionen np.grad2rad()und np.rad2grad().",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Rechnen mit Arrays</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_calculation.html#vergleiche",
    "href": "books/w-python-numpy-grundlagen/skript/array_calculation.html#vergleiche",
    "title": "16  Rechnen mit Arrays",
    "section": "16.2 Vergleiche",
    "text": "16.2 Vergleiche\nNumPy-Arrays lassen sich auch miteinander vergleichen. Betrachten wir die folgenden zwei Arrays:\n\na = np.array([1, 2, 3, 4, 5])\n\nb = np.array([9, 2, 7, 4, 5])\n\nMöchten wir feststellen, ob diese zwei Arrays identisch sind, können wir den ==-Komparator benutzen. Dieser vergleicht die Arrays elementweise.\n\na == b\n\narray([False,  True, False,  True,  True])\n\n\nEs ist außerdem möglich Arrays mit den &gt;- und &lt;-Operatoren zu vergleichen:\n\na &lt; b\n\narray([ True, False,  True, False, False])\n\n\nMöchte man Arrays mit Gleitkommazahlen vergleichen, ist es oftmals nötig, eine gewisse Toleranz zu benutzen, da bei Rechenoperationen minimale Rundungsfehler entstehen können.\n\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\na == b\n\nnp.False_\n\n\nFür diesen Fall gibt es eine Vergleichsfunktion np.isclose(a,b,atol), wobei atol für die absolute Toleranz steht. Im folgenden Beispiel wird eine absolute Toleranz von 0,001 verwendet.\n\na = np.array(0.1 + 0.2)\nb = np.array(0.3)\nprint(np.isclose(a, b, atol=0.001))\n\nTrue\n\n\n\n\n\n\n\n\nWarum ist 0.1 + 0.2 nicht gleich 0.3?\n\n\n\n\n\nZahlen werden intern als Binärzahlen dargestellt. So wie 1/3 nicht mit einer endlichen Anzahl an Ziffern korrekt dargestellt werden kann müssen Zahlen ggf. gerundet werden, um im Binärsystem dargestellt zu werden.\n\na = 0.1\nb = 0.2\nprint(a + b)\n\n0.30000000000000004",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Rechnen mit Arrays</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_calculation.html#aggregatfunktionen",
    "href": "books/w-python-numpy-grundlagen/skript/array_calculation.html#aggregatfunktionen",
    "title": "16  Rechnen mit Arrays",
    "section": "16.3 Aggregatfunktionen",
    "text": "16.3 Aggregatfunktionen\nFür verschiedene Auswertungen benötigen wir Funktionen, wie etwa die Summen oder die Mittelwert-Funktion. Starten wir mit einem Beispiel Array a:\n\na = np.array([1, 2, 3, 4, 8])\n\nDie Summer wird über die Funktion np.sum() berechnet.\n\nnp.sum(a)\n\nnp.int64(18)\n\n\nNatürlich lassen sich auch der Minimalwert und der Maximalwert eines Arrays ermitteln. Die beiden Funktionen lauten np.min()und np.max().\n\nnp.min(a)\n\nnp.int64(1)\n\n\nMöchte man nicht das Maximum selbst, sondern die Position des Maximums bestimmen, wird statt np.max die Funktion np.argmaxverwendet.\nFür statistische Auswertungen werden häufig die Funktion für den Mittelwert np.mean(), die Funktion für den Median np.median()und die Funktion für die Standardabweichung np.std()verwendet.\n\nnp.mean(a)\n\nnp.float64(3.6)\n\n\n\nnp.median(a)\n\nnp.float64(3.0)\n\n\n\nnp.std(a)\n\nnp.float64(2.4166091947189146)\n\n\n\n\n\n\n\n\nZwischenübung: Rechnen mit Arrays\n\n\n\n\n\nGegeben sind zwei eindimensionale Arrays a und b:\na = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) und b = np.array([5, 15, 25, 35, 45, 55, 65, 75, 85, 95])\n\nErstellen Sie ein neues Array, das die Sinuswerte der addierten Arrays a und b enthält.\nBerechnen Sie die Summe, den Mittelwert und die Standardabweichung der Elemente in a.\nFinden Sie den größten und den kleinsten Wert in a und b.\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\na = np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100])\nb = np.array([5, 15, 25, 35, 45, 55, 65, 75, 85, 95])\n\n# 1.\nsin_ab = np.sin(a + b)\n\n# 2.\nsum_a = np.sum(a)\nmean_a = np.mean(a)\nstd_a = np.std(a)\n\n# 3.\nmax_a = np.max(a)\nmin_a = np.min(a)\nmax_b = np.max(b)\nmin_b = np.min(b)",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Rechnen mit Arrays</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_slicing.html",
    "href": "books/w-python-numpy-grundlagen/skript/array_slicing.html",
    "title": "17  Slicing",
    "section": "",
    "text": "17.1 Normales Slicing mit Zahlenwerten\nMöchte man jetzt Daten innerhalb eines Arrays auswählen so geschieht das in der Form:\nliste = np.array([1, 2, 3, 4, 5, 6])\n# Auswählen des ersten Elements\nliste[0]\n\nnp.int64(1)\n# Auswählen des letzen Elements\nliste[-1]\n\nnp.int64(6)\n# Auswählen einer Reihe von Elementen\nliste[1:4]\n\narray([2, 3, 4])\nFür zwei-dimensionale Arrays wählt man getrennt durch ein Komma mit einer zweiten Zahl die zweite Dimension aus.\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\n# Auswählen einer Elements\nmatrix[1,1]\n\nnp.int64(5)\nFür drei-dimensionale Arrays wählt man getrennt durch ein Komma mit einer weiteren Zahl die dritte Dimension aus. Dabei wird dieses jedoch an die erste Stelle gesetzt.\nmatrix_3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])\nprint(matrix_3d)\n\n[[[ 1  2  3]\n  [ 4  5  6]]\n\n [[ 7  8  9]\n  [10 11 12]]]\n# Auswählen eines Elements\nmatrix_3d[1,0,2]\n\nnp.int64(9)",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Slicing</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_slicing.html#normales-slicing-mit-zahlenwerten",
    "href": "books/w-python-numpy-grundlagen/skript/array_slicing.html#normales-slicing-mit-zahlenwerten",
    "title": "17  Slicing",
    "section": "",
    "text": "Figure 17.1: Ansprechen der einzelnen Achsen für den ein-, zwei- und dreidimensionallen Fall inkl. jeweiligem Beispiel\n\n\n\n\n\n[a] wobei ein einzelner Wert an Position a ausgegeben wird\n[a:b] wobei alle Werte von Position a bis Position b-1 ausgegeben werden\n[a:b:c] wobei die Werte von Position a bis Position b-1 mit einer Schrittweite von c ausgegeben werden",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Slicing</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_slicing.html#slicing-mit-logischen-werten-boolesche-masken",
    "href": "books/w-python-numpy-grundlagen/skript/array_slicing.html#slicing-mit-logischen-werten-boolesche-masken",
    "title": "17  Slicing",
    "section": "17.2 Slicing mit logischen Werten (Boolesche Masken)",
    "text": "17.2 Slicing mit logischen Werten (Boolesche Masken)\nBeim logischen Slicing wird eine boolesche Maske verwendet, um bestimmte Elemente eines Arrays auszuwählen. Die Maske ist ein Array gleicher Länge wie das Original, das aus True oder False Werten besteht.\n\n# Erstellen wir ein Beispiel Array\na = np.array([1, 2, 3, 4, 5, 6])\n\n# Erstellen der Maske\nmaske = a &gt; 3\n\nprint(maske)\n\n[False False False  True  True  True]\n\n\nWir erhalten also ein Array mit boolschen Werten. Verwenden wir diese Maske nun zum slicen, erhalten wir alle Werte an den Stellen, an denen die Maske den Wert True besitzt.\n\n# Anwenden der Maske\nprint(a[maske])\n\n[4 5 6]\n\n\n\n\n\n\n\n\nWarning\n\n\n\nDas Verwenden von booleschen Arrays ist nur im numpy-Modul möglich. Es ist nicht Möglich dieses Vorgehen auf native Python Listen anzuwenden. Hier muss durch die Liste iterriert werden.\n\na = [1, 2, 3, 4, 5, 6]\nergebniss = [x for x in a if x &gt; 3]\nprint(ergebniss) \n\n[4, 5, 6]\n\n\n\n\n\n\n\n\n\n\nZwischenübung: Array-Slicing\n\n\n\n\n\nWählen Sie die farblich markierten Bereiche aus dem Array “matrix” mit den eben gelernten Möglichkeiten des Array-Slicing aus.\n\n\nmatrix = np.array([\n    [2, 11, 18, 47, 33, 48, 9, 31, 8, 41],\n    [55, 1, 8, 3, 91, 56, 17, 54, 23, 12],\n    [19, 99, 56, 72, 6, 13, 34, 16, 77, 56],\n    [37, 75, 67, 5, 46, 98, 57, 19, 14, 7],\n    [4, 57, 32, 78, 56, 12, 43, 61, 3, 88],\n    [96, 16, 92, 18, 50, 90, 35, 15, 36, 97],\n    [75, 4, 38, 53, 1, 79, 56, 73, 45, 56],\n    [15, 76, 11, 93, 87, 8, 2, 58, 86, 94],\n    [51, 14, 60, 57, 74, 42, 59, 71, 88, 52],\n    [49, 6, 43, 39, 17, 18, 95, 6, 44, 75]\n])\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nRot: matrix[1,3]\nGrün: matrix[4:6,2:6]\nPink: matrix[:,7]\nOrange: matrix[7,:5]\nBlau: matrix[-1,-1]",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Slicing</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_manipulation.html",
    "href": "books/w-python-numpy-grundlagen/skript/array_manipulation.html",
    "title": "18  Array Manipulation",
    "section": "",
    "text": "18.1 Ändern der Form\nDurch verschiedene Funktionen lassen sich die Form und die Einträge der Arrays verändern.\nEine der wichtigsten Array Operationen ist das Transponieren. Dabei werden Reihen in Spalten und Spalten in Reihe umgewandelt.\nmatrix = np.array([[1, 2, 3], [4, 5, 6]])\nprint(matrix)\n\n[[1 2 3]\n [4 5 6]]\nTransponieren wir dieses Array nun erhalten wir:\nprint(np.transpose(matrix))\n\n[[1 4]\n [2 5]\n [3 6]]\nHaben wir ein nun diese Matrix und wollen daraus einen Vektor erstellen so können wir die Funktion np.flatten() benutzen:\nvector = matrix.flatten()\nprint(vector)\n\n[1 2 3 4 5 6]\nUm wieder eine zweidimensionale Datenstruktur zu erhalten, benutzen wir die Funktion np.reshape(Ziel, Form)\nprint(np.reshape(matrix, [3, 2]))\n\n[[1 2]\n [3 4]\n [5 6]]\nMöchten wir den Inhalt eines bereits bestehenden Arrays erweitern, verkleinern oder ändern bietet NumPy ebenfalls die passenden Funktionen.\nHaben wir ein leeres Array oder wollen wir ein schon volles Array erweitern benutzen wir die Funktion np.append(). Dabei hängen wir einen Wert an das bereits bestehende Array an.\nliste = np.array([1, 2, 3, 4, 5, 6])\n\nneue_liste = np.append(liste, 7)\nprint(neue_liste)\n\n[1 2 3 4 5 6 7]\nGegebenenfalls ist es nötig einen Wert nicht am Ende, sondern an einer beliebigen Position im Array einzufügen. Das passende Werkzeug ist hier die Funktion np.insert(Array, Position, Einschub). Im folgenden Beispiel wird an der dritten Stelle die Zahl 7 eingesetzt.\nliste = np.array([1, 2, 3, 4, 5, 6])\n\nneue_liste = np.insert(liste, 3, 7)\nprint(neue_liste)\n\n[1 2 3 7 4 5 6]\nWenn sich neue Elemente einfügen lassen, können natürlich auch Elemente gelöscht werden. Hierfür wird die Funktion np.delete(Array , Position) benutzt, die ein Array und die Position der zu löschenden Funktion übergeben bekommt.\nliste = np.array([1, 2, 3, 4, 5, 6])\n\nneue_liste = np.delete(liste, 3)\nprint(neue_liste)\n\n[1 2 3 5 6]\nZuletzt wollen wir uns noch die Verbindung zweier Arrays anschauen. Im folgenden Beispiel wird dabei das Array b an das Array a mithilfe der Funktion np.concatenate((Array a, Array b))angehängt.\na = np.array([1, 2, 3, 4, 5, 6])\nb = np.array([7, 8, 9, 10])\n\nneue_liste = np.concatenate((a, b))\nprint(neue_liste)\n\n[ 1  2  3  4  5  6  7  8  9 10]",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Array Manipulation</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_manipulation.html#sortieren-von-arrays",
    "href": "books/w-python-numpy-grundlagen/skript/array_manipulation.html#sortieren-von-arrays",
    "title": "18  Array Manipulation",
    "section": "18.2 Sortieren von Arrays",
    "text": "18.2 Sortieren von Arrays\nNumPy bietet auch die Möglichkeit, Arrays zu sortieren. Im folgenden Beispiel starten wir mit einem unsortierten Array. Mit der Funktion np.sort() erhalten wir ein sortiertes Array.\n\nimport numpy as np\nunsortiert = np.array([4, 2, 1, 6, 3, 5])\n\nsortiert = np.sort(unsortiert)\n\nprint(sortiert)\n\n[1 2 3 4 5 6]",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Array Manipulation</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_manipulation.html#unterlisten-mit-einzigartigen-werten",
    "href": "books/w-python-numpy-grundlagen/skript/array_manipulation.html#unterlisten-mit-einzigartigen-werten",
    "title": "18  Array Manipulation",
    "section": "18.3 Unterlisten mit einzigartigen Werten",
    "text": "18.3 Unterlisten mit einzigartigen Werten\nArbeitet man mit Daten bei denen zum Beispiel Projekte Personalnummern zugeordnet werden hat man Daten mit einer endlichen Anzahl an Personalnummern, die jedoch mehrfach vorkommen können wenn diese an mehr als einem Projekt gleichzeitig arbeiten.\nMöchte man nun eine Liste die jede Nummer nur einmal enthält, kann die Funtkion np.unique verwendet werden.\n\nimport numpy as np\nliste_mit_dopplungen = np.array([4, 1, 1, 6, 3, 4, 7, 3, 3])\n\neinzigartige_werte = np.unique(liste_mit_dopplungen)\n\nprint(einzigartige_werte)\n\n[1 3 4 6 7]\n\n\nSetzt man dann noch die Option return_counts=True kann in einer zweiten Variable gespeichert werden, wie oft jeder Wert vorkommt.\n\nimport numpy as np\nliste_mit_dopplungen = np.array([4, 1, 1, 6, 3, 4, 7, 3, 3])\n\neinzigartige_werte, anzahl = np.unique(liste_mit_dopplungen, return_counts=True)\n\nprint(anzahl)\n\n[2 3 2 1 1]\n\n\n\n\n\n\n\n\nZwischenübung: Arraymanipulation\n\n\n\n\n\nGegeben ist das folgende zweidimensionale Array matrix:\n\nmatrix = np.array([\n    [4, 7, 2, 8],\n    [1, 5, 3, 6],\n    [9, 2, 4, 7]\n])\n\n\nÄndern Sie die Form des Arrays matrix in ein eindimensionales Array.\nSortieren Sie das eindimensionale Array in aufsteigender Reihenfolge.\nÄndern Sie die Form des sortierten Arrays in ein zweidimensionales Array mit 2 Zeilen und 6 Spalten.\nBestimmen Sie die eindeutigen Elemente im ursprünglichen Array matrix und geben Sie diese aus.\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nmatrix = np.array([\n    [4, 7, 2, 8],\n    [1, 5, 3, 6],\n    [9, 2, 4, 7]\n])\n\n# 1. Ändern der Form in ein eindimensionales Array\nflat_array = matrix.flatten()\n\n# 2. Sortieren des eindimensionalen Arrays in aufsteigender Reihenfolge\nsorted_array = np.sort(flat_array)\n\n# 3. Ändern der Form des sortierten Arrays in ein 2x6-Array\nreshaped_array = sorted_array.reshape(2, 6)\n\n# 4. Bestimmen der eindeutigen Elemente im ursprünglichen Array\nunique_elements_original = np.unique(matrix)",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Array Manipulation</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_read_n_write.html",
    "href": "books/w-python-numpy-grundlagen/skript/array_read_n_write.html",
    "title": "19  Lesen und Schreiben von Dateien",
    "section": "",
    "text": "19.1 Lesen von Dateien\nDas Modul numpy stellt Funktionen zum Lesen und Schreiben von strukturierten Textdateien bereit.\nZum Lesen von strukturierten Textdateien, z.B. im CSV-Format (comma separated values), kann die np.loadtxt()-Funktion verwendet werden. Diese bekommt als Argumente den einzulesenden Dateinamen und weitere Optionen zur Definition der Struktur der Daten. Der Rückgabewert ist ein (mehrdimensionales) Array.\nIm folgenden Beispiel wird die Datei TC01.csv eingelesen und deren Inhalt graphisch dargestellt. Die erste Zeile der Datei wird dabei ignoriert, da sie als Kommentar – eingeleitet durch das #-Zeichen – interpretiert wird.\ndateiname = '01-daten/TC01.csv'\ndaten = np.loadtxt(dateiname)\nprint(\"Daten:\", daten)\nprint(\"Form:\", daten.shape)\n\nDaten: [20.1 20.1 20.1 ... 24.3 24.2 24.2]\nForm: (1513,)\nplt.plot(daten)\nplt.xlabel('Datenindex')\nplt.ylabel('Temperatur in °C');\nStandardmäßig erwartet die np.loadtxt()-Funktion Komma separierte Werte. Werden die Daten durch ein anderes Trennzeichen getrennt, kann mit der Option delimiter = \"\" ein anderes Trenzeichen ausgewählt werden. Beispielsweise würde der Funktionsaufruf bei einem Semikolon folgendermaßen aussehen: np.loadtxt(data.txt, delimiter = \";\")\nBeginnt die Datei mit den Daten mit Zeilen bezüglich zusätzlichen Informationen wie Einheiten oder Experimentdaten, können diese mit der Option skiprows= #Reihenübersprungen werden.",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Lesen und Schreiben von Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_read_n_write.html#schreiben-von-dateien",
    "href": "books/w-python-numpy-grundlagen/skript/array_read_n_write.html#schreiben-von-dateien",
    "title": "19  Lesen und Schreiben von Dateien",
    "section": "19.2 Schreiben von Dateien",
    "text": "19.2 Schreiben von Dateien\nZum Schreiben von Arrays in Dateien, kann die in numpy verfügbare Funktion np.savetxt() verwendet werden. Dieser müssen mindestens die zu schreibenden Arrays als auch ein Dateiname übergeben werden. Darüber hinaus sind zahlreiche Formatierungs- bzw. Strukturierungsoptionen möglich.\nFolgendes Beispiel skaliert die oben eingelesenen Daten und schreib jeden zehnten Wert in eine Datei. Dabei wird auch ein Kommentar (header-Argument) am Anfang der Datei erzeugt. Das Ausgabeformat der Zahlen kann mit dem fmt-Argument angegeben werden. Das Format ähnelt der Darstellungsweise, welche bei den formatierten Zeichenketten vorgestellt wurde.\n\nwertebereich = np.max(daten) - np.min(daten)\ndaten_skaliert = ( daten - np.min(daten) ) / wertebereich\ndaten_skaliert = daten_skaliert[::10]\n\n\nplt.plot(daten_skaliert)\nplt.xlabel('Datenindex')\nplt.ylabel('Skalierte Temperatur');\n\n\n\n\n\n\n\n\nBeim Schreiben der Datei wird ein mehrzeiliger Kommentar mithilfe des Zeilenumbruchzeichens \\n definiert. Die Ausgabe der Gleitkommazahlen wird mit %5.2f formatiert, was 5 Stellen insgesamt und zwei Nachkommastellen entspricht.\n\n# Zuweisung ist auf mehrere Zeilen aufgeteilt, aufgrund der \n# schmalen Darstellung im Skript\nkommentar = f'Daten aus {dateiname} skaliert auf den Bereich ' + \\\n             '0 bis 1 \\noriginales Min / Max:' + \\\n            f'{np.min(daten)}/{np.max(daten)}'\nneu_dateiname = '01-daten/TC01_skaliert.csv'\n\nnp.savetxt(neu_dateiname, daten_skaliert, \n           header=kommentar, fmt='%5.2f')\n\nZum Veranschaulichen werden die ersten Zeilen der neuen Datei ausgegeben.\n\n# Einlesen der ersten Zeilen der neu erstellten Datei\ndatei = open(neu_dateiname, 'r')\nfor i in range(10):\n    print( datei.readline() , end='')\ndatei.close()\n\n# Daten aus 01-daten/TC01.csv skaliert auf den Bereich 0 bis 1 \n# originales Min / Max:20.1/31.1\n 0.00\n 0.00\n 0.00\n 0.01\n 0.01\n 0.01\n 0.01\n 0.01",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Lesen und Schreiben von Dateien</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/array_images.html",
    "href": "books/w-python-numpy-grundlagen/skript/array_images.html",
    "title": "20  Arbeiten mit Bildern",
    "section": "",
    "text": "Bilder werden digital als Matrizen gespeichert. Dabei werden pro Pixel drei Farbwerte (rot, grün, blau) gespeichert. Aus diesen drei Farbwerten (Wert 0-255) werden dann alle gewünschten Farben zusammengestellt.\n\n\n\n\n\n\nFigure 20.1: Ein hochaufgelöstes Bild besteht aus sehr vielen Pixeln. Jedes Pixel enthät 3 Farbwerte, einen für die Fabre Grün, einen für Blau und einen für Rot.\n\n\n\nAufgrund der digitalen Darstellung von Bildern lassen sich diese mit den Werkzeugen von NumPy leicht bearbeiten. Wir verwenden für folgendes Beispiel als Bild die Monas Lisa. Das Bild ist unter folgendem Link zu finden.\nImportieren wir dieses Bild nun mit der Funktion imread()aus dem matplotlib-package, sehen wir das es um ein dreidimensionales numpy Array handelt.\n\nimport matplotlib.pyplot as plt\n\ndata = plt.imread(\"00-bilder/mona_lisa.jpg\")\nprint(\"Form:\", data.shape)\n\nForm: (1024, 677, 3)\n\n\nSchauen wir uns einmal mit der print()-Funktion einen Ausschnitt dieser Daten an.\n\nprint(data)\n\n[[[ 68  62  38]\n  [ 88  82  56]\n  [ 92  87  55]\n  ...\n  [ 54  97  44]\n  [ 68 110  60]\n  [ 69 111  63]]\n\n [[ 65  59  33]\n  [ 68  63  34]\n  [ 83  78  46]\n  ...\n  [ 66 103  51]\n  [ 66 103  52]\n  [ 66 102  56]]\n\n [[ 97  90  62]\n  [ 87  80  51]\n  [ 78  72  38]\n  ...\n  [ 79 106  53]\n  [ 62  89  38]\n  [ 62  88  41]]\n\n ...\n\n [[ 25  14  18]\n  [ 21  10  14]\n  [ 20   9  13]\n  ...\n  [ 11   5   9]\n  [ 11   5   9]\n  [ 10   4   8]]\n\n [[ 23  12  16]\n  [ 23  12  16]\n  [ 21  10  14]\n  ...\n  [ 11   5   9]\n  [ 11   5   9]\n  [ 10   4   8]]\n\n [[ 22  11  15]\n  [ 26  15  19]\n  [ 24  13  17]\n  ...\n  [ 11   5   9]\n  [ 10   4   8]\n  [  9   3   7]]]\n\n\nMit der Funktion plt.imshow kann das Bild in Echtfarben dargestellt werden. Dies funktioniert, da die Funktion die einzelnen Ebenen, hier der letzte Index, des Datensatzes als Farbinformationen (rot, grün, blau) interpretiert. Wäre noch eine vierte Ebene dabei, würde sie als individueller Transparenzwert verwendet worden.\n\nplt.imshow(data)\n\n\n\n\n\n\n\n\nNatürlich können auch die einzelnen Farbebenen individuell betrachtet werden. Dazu wird der letzte Index festgehalten. Hier betrachten wir nur den roten Anteil des Bildes. Stellen wir ein einfaches Array dar, werden die Daten in schwarz-weiß ausgegeben. Mit Hilfe der Option cmap='Reds' können wir die Farbskala anpassen.\n\n# Als Farbskale wird die Rotskala \n# verwendet 'Reds'\nplt.imshow( data[:,:,0], cmap='Reds' )\nplt.colorbar()\nplt.show()\n\n\n\n\n\n\n\n\nDa die Bilddaten als Arrays gespeichert sind, sind viele der möglichen Optionen, z.B. zur Teilauswahl oder Operationen, verfügbar. Das untere Beispiel zeigt einen Ausschnitt im Rotkanal des Bildes.\n\nbereich = np.array(data[450:500, 550:600,0], dtype=float)\nplt.imshow( bereich, cmap=\"Greys\" )\nplt.colorbar()\n\n\n\n\n\n\n\n\nBetrachten wir nun eine komplexere Operation an Bilddaten, den Laplace-Operator. Er kann genutzt werden um Ränder von Objekten zu identifizieren. Dazu wird für jeden Bildpunkt \\(B_{i,j}\\) – außer an den Rändern – folgender Wert \\(\\phi_{i, j}\\) berechnet:\n\\[ \\phi_{i, j} = \\left|B_{i-1, j} + B_{i, j-1} - 4\\cdot B_{i, j} + B_{i+1, j} + B_{i, j+1}\\right| \\]\nFolgende Funktion implementiert diese Operation. Darüber hinaus werden alle Werte von \\(\\phi\\) unterhalb eines Schwellwerts auf Null und oberhalb auf 255 gesetzt.\n\ndef img_lap(data, schwellwert=25):\n    \n    # Erstellung einer Kopie der Daten, nun jedoch als\n    # Array mit Gleitkommazahlen\n    bereich = np.array(data, dtype=float)\n    \n    # Aufteilung der obigen Gleichung in zwei Teile\n    lapx = bereich[2:, :] - 2*bereich[1:-1, :] + bereich[:-2, :]\n    lapy = bereich[:, 2:] - 2*bereich[:, 1:-1] + bereich[:, :-2]\n    \n    # Zusammenführung der Teile und Bildung des Betrags\n    lap = np.abs(lapx[:,1:-1] + lapy[1:-1, :])\n    \n    # Schwellwertanalyse\n    lap[lap &gt; schwellwert] = 255\n    lap[lap &lt; schwellwert] = 0\n    \n    return lap\n\nBetrachten wir ein Bild vom Haspel Campus in Wuppertal ein: Bild. Die Anwendung des Laplace-Operators auf den oberen Bildausschnitt ergibt folgende Ausgabe:\n\ndata = plt.imread('01-daten/campus_haspel.jpeg')\nbereich = np.array(data[1320:1620, 400:700, 1], dtype=float)\n\nlap = img_lap(bereich)\n\nplt.figure(figsize=(9, 3))\n\nax = plt.subplot(1, 3, 1)\nax.imshow(data, cmap=\"Greys_r\")\n\nax = plt.subplot(1, 3, 2)\nax.imshow(bereich, cmap=\"Greys_r\");\n\nax = plt.subplot(1, 3, 3)\nax.imshow(lap, cmap=\"Greys\");\n\n\n\n\n\n\n\n\nWir können damit ganz klar die Formen des Fensters erkennen.\nWollen wir zum Beispiel eine Farbkomponente bearbeiten und dann das Bild wieder zusammensetzen, benötigen wir die Funktion np.dstack((rot, grün, blau)).astype('uint8'), wobei rot, grünund blau die jeweiligen 2D-Arrays sind. Versuchen wir nun die grüne Farbe aus dem Baum links zu entfernen.\nWichtig ist, dass die Daten nach dem Zusammensetzen im Format uint8 vorliegen, deswegen die Methode .astype('uint8').\n\ndata = plt.imread('01-daten/campus_haspel.jpeg')\n\n# Speichern der einzelnen Farben in Arrays\nrot = np.array(data[:, :, 0], dtype=float)\ngruen = np.array(data[:, :, 1], dtype=float)\nblau = np.array(data[:, :, 2], dtype=float)\n\n# Setzen wir den Bereich des linken Baumes im Array auf 0\ngruen_neu = gruen.copy()\ngruen_neu[800:2000, 700:1700] = 0\n\nzusammengesetzt = np.dstack((rot, gruen_neu, blau)).astype('uint8')\n\nplt.figure(figsize=(8, 5))\n\nax = plt.subplot(1, 2, 1)\nax.imshow(data, cmap=\"Greys_r\")\n\nax = plt.subplot(1, 2, 2)\nax.imshow(zusammengesetzt)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nZwischenübung: Bilder bearbeiten\n\n\n\n\n\nLesen Sie folgendes Bild vom Haspel Campus in Wuppertal ein: Bild\nExtrahieren Sie den blauen Anteil und lassen Sie sich die Zeile in der Mitte des Bildes ausgeben, so wie einen beliebigen Bildauschnitt.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndata = plt.imread('01-daten/campus_haspel.jpeg')\n\nform =  data.shape\nprint( \"Form:\", data.shape )\n\nblau =  data[:,:,2]\nplt.imshow(blau, cmap='Blues')\n\nzeile =  data[int(form[0]/2),:,2]\nprint(zeile)\n\nausschnitt =  data[10:50,10:50,:]\nplt.imshow(ausschnitt)\n\nForm: (3024, 4032, 3)\n[221 220 220 ...  28  28  28]",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Arbeiten mit Bildern</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html",
    "title": "21  Lernzielkontrolle",
    "section": "",
    "text": "Aufgabe 1\nHerzlich willkommen zur Lernzielkontrolle!\nDiese Selbstlernkontrolle dient dazu, Ihr Verständnis der bisher behandelten Themen zu überprüfen und Ihnen die Möglichkeit zu geben, Ihren Lernfortschritt eigenständig zu bewerten. Sie ist so konzipiert, dass Sie Ihre Stärken und Schwächen erkennen und gezielt an den Bereichen arbeiten können, die noch verbessert werden müssen.\nEs stehen hier zwei Möglichkeiten zur Verfügung ihr Wissen zu prüfen. Sie können das Quiz benutzen, welches Sie automatisch durch die verschiedenen Themen führt. ALternativ finden Sie darunter normale Frage wie Sie bisher im Skript verwendet wurden.\nBitte nehmen Sie sich ausreichend Zeit für die Bearbeitung der Fragen und gehen Sie diese in Ruhe durch. Seien Sie ehrlich zu sich selbst und versuchen Sie, die Aufgaben ohne Hilfsmittel zu lösen, um ein realistisches Bild Ihres aktuellen Wissensstands zu erhalten. Sollten Sie bei einer Frage Schwierigkeiten haben, ist dies ein Hinweis darauf, dass Sie in diesem Bereich noch weiter üben sollten.\nViel Erfolg bei der Bearbeitung und beim weiteren Lernen!\nWie wird das NumPy-Paket typischerweise eingebunden?",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-2",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-2",
    "title": "21  Lernzielkontrolle",
    "section": "Aufgabe 2",
    "text": "Aufgabe 2\nErstellen Sie mit Hilfe von NumPy die folgenden Arrays:\n\nErstellen sie aus der Liste [1, 2, 3] ein numPy Array\nEin eindimensionales Array, das die Zahlen von 0 bis 9 enthält.\nEin zweidimensionales Array der Form 3×33×3, das nur aus Einsen besteht.\nEin eindimensionales Array, das die Zahlen von 10 bis 50 (einschließlich) in Schritten von 5 enthält.",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-3",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-3",
    "title": "21  Lernzielkontrolle",
    "section": "Aufgabe 3",
    "text": "Aufgabe 3\nWas ist der Unterschied zwischenden den Funktionen np.ndim, np.shape und np.size",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-4",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-4",
    "title": "21  Lernzielkontrolle",
    "section": "Aufgabe 4",
    "text": "Aufgabe 4\nWelchen Datentyp besitzt folgendes Array? Mit welcher Funktion kann ich den Datentypen eines Arrays auslesen?\n\nvector = np.array([ 4.8,  8.2, 15.6, 16.6, 23.2, 42.8 ])",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-5",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-5",
    "title": "21  Lernzielkontrolle",
    "section": "Aufgabe 5",
    "text": "Aufgabe 5\nFühren Sie mit den folgenden zwei Arrays diese mathematischen Operationen durch:\na = [5, 1, 3, 6, 4] und b = [6, 5, 2, 6, 9]\n\nAddieren Sie beide Arrays\nBerechnen Sie das elementweise Produkt von a und b\nAddieren Sie zu jedem Eintrag von a 3 dazu",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-6",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-6",
    "title": "21  Lernzielkontrolle",
    "section": "Aufgabe 6",
    "text": "Aufgabe 6\na = [9, 2, 3, 1, 3]\n\nBestimmen Sie Mittelwert und Standardabweichung für das Array a\nBestimmen Sie Minimum und Maximum der Liste",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-7",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-7",
    "title": "21  Lernzielkontrolle",
    "section": "Aufgabe 7",
    "text": "Aufgabe 7\n\nmatrix = np.array([\n    [ 1,  2,  3,  4,  5],\n    [ 6,  7,  8,  9, 10],\n    [11, 12, 13, 14, 15],\n    [16, 17, 18, 19, 20],\n    [21, 22, 23, 24, 25]\n])\n\n\nExtrahieren Sie die erste Zeile.\nExtrahieren Sie die letzte Spalte.\nExtrahieren Sie die Untermatrix, die aus den Zeilen 2 bis 4 und den Spalten 1 bis 3 besteht.",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-8",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-8",
    "title": "21  Lernzielkontrolle",
    "section": "Aufgabe 8",
    "text": "Aufgabe 8\n\narray = np.arange(1, 21)\n\n\nÄndern Sie die Form des Arrays in eine zweidimensionale Matrix der Form 4×5.\nÄndern Sie die Form des Arrays in eine zweidimensionale Matrix der Form 5×4.\nÄndern Sie die Form des Arrays in eine dreidimensionale Matrix der Form 2×2×5.\nFlachen Sie das dreidimensionale Array aus Aufgabe 3 wieder zu einem eindimensionalen Array ab.\nTransponieren Sie die 4×54×5-Matrix aus Aufgabe 1.",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-9",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-9",
    "title": "21  Lernzielkontrolle",
    "section": "Aufgabe 9",
    "text": "Aufgabe 9\nMit welchen zwei Funktionen können Daten aus einer Datei gelesen und in einer Datei gespeichert werden?",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-10",
    "href": "books/w-python-numpy-grundlagen/skript/assessment.html#aufgabe-10",
    "title": "21  Lernzielkontrolle",
    "section": "Aufgabe 10",
    "text": "Aufgabe 10\nSie möchten aus einem Bild die Bilddaten einer Farkomponente isolieren. Was müssen Sie dafür tun?\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nAufgabe 1\n\nimport numpy as np\n\n\n\nAufgabe 2\n\n# 1.\nnp.array([1, 2, 3])\n\n# 2. \nprint(np.arange(10))\n\n# 3. \nprint(np.ones((3, 3)))\n\n# 4. \nprint(np.arange(10, 51, 5))\n\n[0 1 2 3 4 5 6 7 8 9]\n[[1. 1. 1.]\n [1. 1. 1.]\n [1. 1. 1.]]\n[10 15 20 25 30 35 40 45 50]\n\n\n\n\nAufgabe 3\nnp.ndim: Gibt die Anzahl der Dimensionen zurück np.shape: Gibt die Längen der einzelnen Dimensionen wieder np.size: Gibt die Anzahl aller Elemente aus\n\n\nAufgabe 4\nDa es sich hier um Gleitkommazahlen handelt, ist der Datentyp float.64.\n\nvector = np.array([ 4.8,  8.2, 15.6, 16.6, 23.2, 42.8 ])\nprint(vector.dtype)\n\nfloat64\n\n\n\n\nAufgabe 5\n\na = np.array([5, 1, 3, 6, 4])\nb = np.array([6, 5, 2, 6, 9])\n\n# 1.\nergebnis = a + b\nprint(\"Die Summe beider Vektoren ergibt: \", ergebnis) \n\n# 2.\nergebnis = a * b\nprint(\"Das Produkt beider Vektoren ergibt: \", ergebnis) \n\n# 3.\nergebnis = a + 3\nprint(\"Die Summe von a und 3 ergibt: \", ergebnis) \n\nDie Summe beider Vektoren ergibt:  [11  6  5 12 13]\nDas Produkt beider Vektoren ergibt:  [30  5  6 36 36]\nDie Summe von a und 3 ergibt:  [8 4 6 9 7]\n\n\n\n\nAufgabe 6\n\na = np.array([9, 2, 3, 1, 3])\n\n# 1.\nmittelwert = np.mean(a)\nprint(\"Der Mittelwert ist: \", mittelwert)\n\nstandardabweichung = np.std(a)\nprint(\"Die Standardabweichung von a beträgt: \", standardabweichung) \n\n# 2.\nminimum = np.min(a)\nprint(\"Das Minimum beträgt: \", minimum)\n\nmaximum = np.max(a)\nprint(\"Das Maximum beträgt: \", maximum)\n\nDer Mittelwert ist:  3.6\nDie Standardabweichung von a beträgt:  2.8000000000000003\nDas Minimum beträgt:  1\nDas Maximum beträgt:  9\n\n\n\n\nAufgabe 7\n\nmatrix = np.array([\n    [ 1,  2,  3,  4,  5],\n    [ 6,  7,  8,  9, 10],\n    [11, 12, 13, 14, 15],\n    [16, 17, 18, 19, 20],\n    [21, 22, 23, 24, 25]\n])\n\n# 1. Erste Zeile\nprint(matrix[0,:])\n\n# 2.\nprint(matrix[:,-1])\n\n# 3.\nprint(matrix[1:4,0:3])\n\n[1 2 3 4 5]\n[ 5 10 15 20 25]\n[[ 6  7  8]\n [11 12 13]\n [16 17 18]]\n\n\n\n\nAufgabe 8\n\narray = np.arange(1, 21)\n\n# 1. Ändern der Form in eine 4x5-Matrix\nmatrix_4x5 = array.reshape(4, 5)\n\n# 2. Ändern der Form in eine 5x4-Matrix\nmatrix_5x4 = array.reshape(5, 4)\n\n# 3. Ändern der Form in eine 2x2x5-Matrix\nmatrix_2x2x5 = array.reshape(2, 2, 5)\n\n# 4. Abflachen der 2x2x5-Matrix zu einem eindimensionalen Array\nflattened_array = matrix_2x2x5.flatten()\n\n# 5. Transponieren der 4x5-Matrix\ntransposed_matrix = matrix_4x5.T\n\n# Ausgabe der Ergebnisse (optional)\nprint(\"Originales Array:\", array)\nprint(\"4x5-Matrix:\\n\", matrix_4x5)\nprint(\"5x4-Matrix:\\n\", matrix_5x4)\nprint(\"2x2x5-Matrix:\\n\", matrix_2x2x5)\nprint(\"Abgeflachtes Array:\", flattened_array)\nprint(\"Transponierte 4x5-Matrix:\\n\", transposed_matrix)\n\nOriginales Array: [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20]\n4x5-Matrix:\n [[ 1  2  3  4  5]\n [ 6  7  8  9 10]\n [11 12 13 14 15]\n [16 17 18 19 20]]\n5x4-Matrix:\n [[ 1  2  3  4]\n [ 5  6  7  8]\n [ 9 10 11 12]\n [13 14 15 16]\n [17 18 19 20]]\n2x2x5-Matrix:\n [[[ 1  2  3  4  5]\n  [ 6  7  8  9 10]]\n\n [[11 12 13 14 15]\n  [16 17 18 19 20]]]\nAbgeflachtes Array: [ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20]\nTransponierte 4x5-Matrix:\n [[ 1  6 11 16]\n [ 2  7 12 17]\n [ 3  8 13 18]\n [ 4  9 14 19]\n [ 5 10 15 20]]\n\n\n\n\nAufgabe 9\nDie passenden Funktionen sind np.loadtxt() und np.savetxt().\n\n\nAufgabe 10\nTypischerweise sind Bilddaten große Matrizen wobei die Farben in drei unterschieldichen Matrizen gespeichert werden. Dabei ist die Farbreihenfolge oft “Rot”, “Grün” und “Blau”. Dementsprechen müssen wir wenn wie Daten in der Matrix data gespeichert sind mit Slicing eine Dimension auswählen: data[:,:,0], wobei die Zahl 0-2 für die jeweilige Farbe steht.",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Lernzielkontrolle</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/uebungen/uebung.html",
    "href": "books/w-python-numpy-grundlagen/uebungen/uebung.html",
    "title": "22  Übung",
    "section": "",
    "text": "22.1 Aufgabe 1 Filmdatenbank\nIn der ersten Aufgabe wollen wir fiktive Daten für Filmbewertungen untersuchen. Das Datenset ist dabei vereinfacht und beinhaltet folgende Spalten:\nHier ist das Datenset:\nimport numpy as np\n\nbewertungen = np.array([\n    [1, 101, 4.5],\n    [1, 102, 3.0],\n    [2, 101, 2.5],\n    [2, 103, 4.0],\n    [3, 101, 5.0],\n    [3, 104, 3.5],\n    [3, 105, 4.0]\n])",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/uebungen/uebung.html#aufgabe-1-filmdatenbank",
    "href": "books/w-python-numpy-grundlagen/uebungen/uebung.html#aufgabe-1-filmdatenbank",
    "title": "22  Übung",
    "section": "",
    "text": "Film ID\nBenutzer ID\nBewertung\n\n\n\n\n\n\n\n\n\na) Bestimmen Sie die jemals niedrigste und höchste Bewertung, die je gegeben wurde\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nniedrigste_bewertung = np.min(bewertungen[:,2])\n\nprint(\"Die niedrigste jemals gegebene Bertung ist:\", niedrigste_bewertung)\n\nhoechste_bewertung = np.max(bewertungen[:,2])\n\nprint(\"Die hoechste jemals gegebene Bertung ist:\", hoechste_bewertung)\n\nDie niedrigste jemals gegebene Bertung ist: 2.5\nDie hoechste jemals gegebene Bertung ist: 5.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb) Nennen Sie alle Bewertungen für Film 1\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nbewertungen_film_1 = bewertungen[np.where(bewertungen[:,0]==1)]\n\nprint(\"Bewertungen für Film 1:\\n\", bewertungen_film_1)\n\nBewertungen für Film 1:\n [[  1.  101.    4.5]\n [  1.  102.    3. ]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nc) Nennen Sie alle Bewertungen von Person 101\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nbewertungen_101 = bewertungen[np.where(bewertungen[:,1]==101)]\n\nprint(\"Bewertungen von Person 101:\\n\", bewertungen_101)\n\nBewertungen von Person 101:\n [[  1.  101.    4.5]\n [  2.  101.    2.5]\n [  3.  101.    5. ]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nd) Berechnen Sie die mittlere Bewertung für jeden Film und geben Sie diese nacheinander aus\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nfor ID in [1, 2, 3]:\n\n    mittelwert = np.mean(bewertungen[np.where(bewertungen[:,0]==ID),2])\n\n    print(\"Die Mittlere Bewertung für Film\", ID, \"beträgt:\", mittelwert) \n\nDie Mittlere Bewertung für Film 1 beträgt: 3.75\nDie Mittlere Bewertung für Film 2 beträgt: 3.25\nDie Mittlere Bewertung für Film 3 beträgt: 4.166666666666667\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ne) Finden SIe den Film mit der höchsten Bewertung\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nindex_hoechste_bewertung = np.argmax(bewertungen[:,2])\n\nprint(bewertungen[index_hoechste_bewertung,:])\n\n[  3. 101.   5.]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nf) Finden Sie die Person mit den meisten Bewertungen\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\neinzigartige_person, anzahl = np.unique(bewertungen[:, 1],return_counts=True)\n\nmeist_aktiver_person = einzigartige_person[np.argmax(anzahl)]\n\nprint(\"Personen mit den meisten Bewertungen:\", meist_aktiver_person)\n\nPersonen mit den meisten Bewertungen: 101.0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ng) Nennen Sie alle Filme mit einer Wertung von 4 oder besser.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nindex_bewertung_besser_vier = bewertungen[:,2] &gt;= 4\n\nprint(\"Filme mit einer Wertung von 4 oder besser:\")\n\nprint(bewertungen[index_bewertung_besser_vier,:])\n\nFilme mit einer Wertung von 4 oder besser:\n[[  1.  101.    4.5]\n [  2.  103.    4. ]\n [  3.  101.    5. ]\n [  3.  105.    4. ]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nh) Film Nr. 4 ist erschienen. Der Film wurde von Person 102 mit einer Note von 3.5 bewertet. Fügen Sie diesen zur Datenbank hinzu.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nneue_bewertung = np.array([4, 102, 3.5])\n\nbewertungen = np.append(bewertungen, [neue_bewertung], axis=0)\n\nprint(bewertungen)\n\n[[  1.  101.    4.5]\n [  1.  102.    3. ]\n [  2.  101.    2.5]\n [  2.  103.    4. ]\n [  3.  101.    5. ]\n [  3.  104.    3.5]\n [  3.  105.    4. ]\n [  4.  102.    3.5]]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ni) Person 102 hat sich Film Nr. 1 nochmal angesehen und hat das Ende jetzt doch verstanden. Dementsprechend soll die Berwertung jetzt auf 5.0 geändert werden.\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nbewertungen[(bewertungen[:, 0] == 1) & \n            (bewertungen[:, 1] == 102), 2] = 5.0\n\nprint(\"Aktualisieren der Bewertung:\\n\", bewertungen)\n\nAktualisieren der Bewertung:\n [[  1.  101.    4.5]\n [  1.  102.    5. ]\n [  2.  101.    2.5]\n [  2.  103.    4. ]\n [  3.  101.    5. ]\n [  3.  104.    3.5]\n [  3.  105.    4. ]\n [  4.  102.    3.5]]",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "books/w-python-numpy-grundlagen/uebungen/uebung.html#aufgabe-2---kryptographie---caesar-chiffre",
    "href": "books/w-python-numpy-grundlagen/uebungen/uebung.html#aufgabe-2---kryptographie---caesar-chiffre",
    "title": "22  Übung",
    "section": "22.2 Aufgabe 2 - Kryptographie - Caesar-Chiffre",
    "text": "22.2 Aufgabe 2 - Kryptographie - Caesar-Chiffre\nIn dieser Aufgabe wollen wir Text sowohl ver- als auch entschlüsseln.\nJedes Zeichen hat über die sogenannte ASCII-Tabelle einen Zahlenwert zugeordnet.\n\n\n\nTable 22.1: Ascii-Tabelle\n\n\n\n\n\nBuchstabe\nASCII Code\nBuchstabe\nASCII Code\n\n\n\n\na\n97\nn\n110\n\n\nb\n98\no\n111\n\n\nc\n99\np\n112\n\n\nd\n100\nq\n113\n\n\ne\n101\nr\n114\n\n\nf\n102\ns\n115\n\n\ng\n103\nt\n116\n\n\nh\n104\nu\n117\n\n\ni\n105\nv\n118\n\n\nj\n106\nw\n119\n\n\nk\n107\nx\n120\n\n\nl\n108\ny\n121\n\n\nm\n109\nz\n122\n\n\n\n\n\n\nDer Einfachheit halber ist im Folgenden schon der Code zur Umwandlung von Buchstaben in Zahlenwerten und wieder zurück aufgeführt. Außerdem beschränken wir uns auf Texte mit kleinen Buchstaben.\nIhre Aufgabe ist nun die Zahlenwerte zu verändern.\nZunächste wollen wir eine einfache Caesar-Chiffre anwenden. Dabei werden alle Buchstaben um eine gewisse Anzahl verschoben. Ist Beispielsweise der der Verschlüsselungswert “1” wird aus einem A ein B, einem M, ein N. Ist der Wert “4” wird aus einem A ein E und aus einem M ein Q. Die Verschiebung findet zyklisch statt, das heißt bei einer Verschiebung von 1 wird aus einem Z ein A.\n\nimport numpy as np\n\n# Funktion, die einen Buchstaben in ihren ASCII-Wert umwandelt\ndef buchstabe_zu_ascii(c):\n    return np.array([ord(c)])\n\n# Funktion, die einen ASCII-Wert in den passenden Buchstaben umwandelt\ndef ascii_zu_buchstabe(a):\n    return chr(a)\n\n\n\n\n\n\n\n1. Überlegen Sie sich zunächst wie man diese zyklische Verschiebung mathematisch ausdrücken könnte (Hinweis: Modulo Rechnung)\n\n\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\\[ \\textrm{ASCII}_{\\textrm{verschoben}} = (\\textrm{ASCII} - 97 + \\textrm{Versatz}) \\textrm{ mod } 26 + 97\\]\n\n\n\n\n\n\n\n\n\n\n\n\n2. Schreiben Sie Code der mit einer Schleife alle Zeichen umwandelt.\n\n\n\n\n\nZunächst sollen alle Zeichen in Ascii Code umgewandelt werden. Dann wird die Formel auf die Zahlenwerte angewendet und schlussendlich in einer dritten schleife wieder alle Werte in Buchstaben übersetzt.\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nimport numpy as np\n\n# Funktion, die einen Buchstaben in ihren ASCII-Wert umwandelt\ndef buchstabe_zu_ascii(c):\n    return ord(c)\n\n# Funktion, die einen ASCII-Wert in den passenden Buchstaben umwandelt\ndef ascii_zu_buchstabe(a):\n    return chr(a)\n\nklartext = \"abrakadabra\"\nversatz = 3\n\numgewandelter_text = []\nverschluesselte_zahl = []\nverschluesselter_text= []\n\n\n\nfor buchstabe in klartext:\n    umgewandelter_text.append(buchstabe_zu_ascii(buchstabe))\nprint(umgewandelter_text)\n\n\nfor zahl in umgewandelter_text:    \n    verschluesselt = (zahl - 97 + versatz) % 26 + 97\n    verschluesselte_zahl.append(verschluesselt)\nprint(verschluesselte_zahl)\n\n\nfor zahl in verschluesselte_zahl:    \n    verschluesselter_text.append(ascii_zu_buchstabe(zahl))\nprint(verschluesselter_text)\n\n[97, 98, 114, 97, 107, 97, 100, 97, 98, 114, 97]\n[100, 101, 117, 100, 110, 100, 103, 100, 101, 117, 100]\n['d', 'e', 'u', 'd', 'n', 'd', 'g', 'd', 'e', 'u', 'd']\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3. Ersetzen Sie die Schleife, indem Sie die Rechenoperation mit einem NumPy-Array durchführen\n\n\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nimport numpy as np\n\n# Funktion, die einen Buchstaben in ihren ASCII-Wert umwandelt\ndef buchstabe_zu_ascii(c):\n    return ord(c)\n\n# Funktion, die einen ASCII-Wert in den passenden Buchstaben umwandelt\ndef ascii_zu_buchstabe(a):\n    return chr(a)\n\nklartext = \"abrakadabra\"\nversatz = 3\n\numgewandelter_text = []\nverschluesselte_zahl = []\nverschluesselter_text= []\n\n\n\nfor buchstabe in klartext:\n    umgewandelter_text.append(buchstabe_zu_ascii(buchstabe))\nprint(umgewandelter_text)\n\numgewandelter_text = np.array(umgewandelter_text)\nverschluesselte_zahl = (umgewandelter_text - 97 + versatz) % 26 + 97\nprint(verschluesselte_zahl)\n\nfor zahl in verschluesselte_zahl:    \n    verschluesselter_text.append(ascii_zu_buchstabe(zahl))\nprint(verschluesselter_text)\n\n[97, 98, 114, 97, 107, 97, 100, 97, 98, 114, 97]\n[100 101 117 100 110 100 103 100 101 117 100]\n['d', 'e', 'u', 'd', 'n', 'd', 'g', 'd', 'e', 'u', 'd']\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4. Schreiben sie den Code so um, dass der verschlüsselte Text entschlüsselt wird.\n\n\n\n\n\n\n\n\n\n\n\nLösung\n\n\n\n\n\n\nimport numpy as np\n\n# Funktion, die einen Buchstaben in ihren ASCII-Wert umwandelt\ndef buchstabe_zu_ascii(c):\n    return ord(c)\n\n# Funktion, die einen ASCII-Wert in den passenden Buchstaben umwandelt\ndef ascii_zu_buchstabe(a):\n    return chr(a)\n\n\nversatz = 3\n\numgewandelter_text = []\nverschluesselte_zahl = []\nentschluesselter_text= []\n\n\n\nfor buchstabe in verschluesselter_text:\n    umgewandelter_text.append(buchstabe_zu_ascii(buchstabe))\nprint(umgewandelter_text)\n\numgewandelter_text = np.array(umgewandelter_text)\nverschluesselte_zahl = (umgewandelter_text - 97 - versatz) % 26 + 97\nprint(verschluesselte_zahl)\n\nfor zahl in verschluesselte_zahl:    \n    entschluesselter_text.append(ascii_zu_buchstabe(zahl))\nprint(entschluesselter_text)\n\n[100, 101, 117, 100, 110, 100, 103, 100, 101, 117, 100]\n[ 97  98 114  97 107  97 100  97  98 114  97]\n['a', 'b', 'r', 'a', 'k', 'a', 'd', 'a', 'b', 'r', 'a']",
    "crumbs": [
      "Numpy",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Übung</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/introduction.html",
    "href": "books/dataanalysis/introduction.html",
    "title": "Datenanalyse und Modellierung",
    "section": "",
    "text": "Einleitung\nIn dieser Einheit lernen Sie, wie man reale Messdaten – etwa aus Experimenten oder Ingenieurprojekten – mit NumPy und Matplotlib verarbeitet und analysiert. Der Fokus liegt dabei auf einem praxisnahen Umgang mit Daten im CSV-Format.",
    "crumbs": [
      "Datenanalyse und Modellierung"
    ]
  },
  {
    "objectID": "books/dataanalysis/introduction.html#lernziele-dieses-kapitels",
    "href": "books/dataanalysis/introduction.html#lernziele-dieses-kapitels",
    "title": "Datenanalyse und Modellierung",
    "section": "Lernziele dieses Kapitels",
    "text": "Lernziele dieses Kapitels\nSie lernen in dieser Einheit:\n\nwie Sie strukturierte CSV-Daten in NumPy-Arrays überführen,\nwie Sie fehlende Werte erkennen und ersetzen,\nwie Sie typische statistische Kennzahlen berechnen,\nwie Sie Daten mit Matplotlib visualisieren,\nwie Sie Daten interpolieren und Trends glätten,\nund wie Sie reale Anwendungen – z. B. aus dem Bauwesen – analysieren.",
    "crumbs": [
      "Datenanalyse und Modellierung"
    ]
  },
  {
    "objectID": "books/dataanalysis/introduction.html#csv-dateien-ein-typisches-format-für-messdaten",
    "href": "books/dataanalysis/introduction.html#csv-dateien-ein-typisches-format-für-messdaten",
    "title": "Datenanalyse und Modellierung",
    "section": "CSV-Dateien: Ein typisches Format für Messdaten",
    "text": "CSV-Dateien: Ein typisches Format für Messdaten\nCSV-Dateien („Comma Separated Values“) sind weit verbreitet – etwa für:\n\nTemperaturverläufe,\nMessreihen aus Experimenten,\nLogdaten von Sensoren.\n\nZu Beginn wird ein Beispiel betrachtet: Temperatur, Luftfeuchtigkeit und CO₂-Werte. Diese Datei enthält auch einige fehlende Werte, wie sie in realen Daten oft vorkommen.\n\nimport numpy as np\ndata = np.genfromtxt(\"beispiel.csv\", delimiter=\",\", skip_header=1)\nprint(data)\n\n[[ 21.1  45.  400. ]\n [ 22.5   nan 420. ]\n [  nan  50.  410. ]\n [ 20.   48.    nan]\n [ 23.3  47.  430. ]]",
    "crumbs": [
      "Datenanalyse und Modellierung"
    ]
  },
  {
    "objectID": "books/dataanalysis/introduction.html#fehlende-werte-erkennen-und-bereinigen",
    "href": "books/dataanalysis/introduction.html#fehlende-werte-erkennen-und-bereinigen",
    "title": "Datenanalyse und Modellierung",
    "section": "Fehlende Werte erkennen und bereinigen",
    "text": "Fehlende Werte erkennen und bereinigen\nFehlende Werte werden beim Einlesen als np.nan (Not a Number) codiert. Zunächst wird gezählt, wie viele Werte fehlen:\n\nprint(np.isnan(data).sum(axis=0))\n\n[1 1 1]\n\n\nUm die Analyse nicht zu verfälschen, werden sie ersetzt – z. B. durch den Mittelwert der Spalte:\n\nfor i in range(data.shape[1]):\n    mean = np.nanmean(data[:, i])\n    data[:, i] = np.where(np.isnan(data[:, i]), mean, data[:, i])",
    "crumbs": [
      "Datenanalyse und Modellierung"
    ]
  },
  {
    "objectID": "books/dataanalysis/introduction.html#statistische-kennzahlen-berechnen",
    "href": "books/dataanalysis/introduction.html#statistische-kennzahlen-berechnen",
    "title": "Datenanalyse und Modellierung",
    "section": "Statistische Kennzahlen berechnen",
    "text": "Statistische Kennzahlen berechnen\nTypische Kennwerte zur Beschreibung von Daten:\n\nMittelwert: Durchschnitt\nStandardabweichung: Streuung\nMinimum und Maximum\n\n\nprint(\"Mittelwerte:\", np.mean(data, axis=0))\nprint(\"Standardabweichung:\", np.std(data, axis=0))\n\nMittelwerte: [ 21.725  47.5   415.   ]\nStandardabweichung: [ 1.13556154  1.61245155 10.        ]",
    "crumbs": [
      "Datenanalyse und Modellierung"
    ]
  },
  {
    "objectID": "books/dataanalysis/introduction.html#daten-visualisieren",
    "href": "books/dataanalysis/introduction.html#daten-visualisieren",
    "title": "Datenanalyse und Modellierung",
    "section": "Daten visualisieren",
    "text": "Daten visualisieren\nMit Matplotlib lassen sich Daten übersichtlich darstellen. Es werden z. B. Linien- und Histogrammplots genutzt.\n\nimport matplotlib.pyplot as plt\n\nlabels = [\"Temperatur (°C)\", \"Luftfeuchtigkeit (%)\", \"CO₂ (ppm)\"]\n\nfor i in range(data.shape[1]):\n    plt.plot(data[:, i], label=labels[i])\nplt.legend()\nplt.title(\"Messwerte im Verlauf\")\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "Datenanalyse und Modellierung"
    ]
  },
  {
    "objectID": "books/dataanalysis/interpolation.html",
    "href": "books/dataanalysis/interpolation.html",
    "title": "23  Interpolation – Lücken schließen",
    "section": "",
    "text": "23.1 Übersicht\nWas tun, wenn Werte fehlen? In vielen Datensätzen gibt es Lücken – zum Beispiel, weil Messungen nur an bestimmten Punkten vorgenommen wurden. Interpolation ist eine Methode, mit der wir Zwischenwerte schätzen können, also Werte innerhalb eines bekannten Wertebereichs.\nIm Gegensatz dazu versucht Extrapolation, Werte außerhalb des bekannten Bereichs vorherzusagen – was in der Regel mit größerer Unsicherheit verbunden ist.\nBei der Interpolation wird eine Modellfunktion gesucht, welche die Messdaten exakt abbildet.\nIn vielen praktischen Anwendungen werden Polynome als Basisfunktionen der Modellfunktion angenommen. Vorteile von Polynomen:\nEin Beispiel für eine Basis aus Polynomen:\n\\[ \\phi_1(x)=1,\\quad \\phi_2(x)=x,\\quad \\phi_3(x)=x^2,\\quad \\cdots,\\quad \\phi_m =x^{m-1} \\]",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Interpolation – Lücken schließen</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/interpolation.html#übersicht",
    "href": "books/dataanalysis/interpolation.html#übersicht",
    "title": "23  Interpolation – Lücken schließen",
    "section": "",
    "text": "Polynome sind leicht zu differenzieren und integrieren\nAnnäherung von beliebigen Funktionen durch Polynome möglich, siehe Taylor-Entwicklung\nAuswertung ist sehr einfach und dadurch schnell, d.h. sie benötigt nur wenige schnelle arithmetische Operationen (Addition und Multiplikation)",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Interpolation – Lücken schließen</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/interpolation.html#polynome",
    "href": "books/dataanalysis/interpolation.html#polynome",
    "title": "23  Interpolation – Lücken schließen",
    "section": "23.2 Polynome",
    "text": "23.2 Polynome\nPolynome \\(P(x)\\) sind Funktionen in Form einer Summe von Potenzfunktionen mit natürlichzahligen Exponenten \\(( x^i, i \\in \\mathbb{N})\\) mit den entsprechenden Koeffzienten \\(a_i\\):\n\\[ P(x) = \\sum_{i=0}^n a_i x^i = a_n x^n + a_{n-1} x^{n-1} + \\cdots + a_2 x^2 + a_1 x + a_0, \\quad i, n \\in \\mathbb{N}, a_i \\in \\mathbb{R} \\]\n\nAls Grad eines Polynoms wird der Term mit dem höchsten Exponenten und nichtverschwindenden Koeffizienten (der sogenannte Leitkoeffizient) bezeichnet.\nEin Polynom mit Grad \\(n\\) hat \\(n\\), teilweise komplexe, Nullstellen.\n\nIn Python, d.h. im numpy-Modul, werden Polynome durch ihre Koeffizienten representiert. Im Allgemeinen wird ein Polynom mit dem Grad \\(n\\) durch folgendes Array dargestellt\n[an, ..., a2, a1, a0]\nSo z.B. für \\(P(x) = x^3 + 5x^2 - 2x + 3\\):\n\nP = np.array([1, 5, -2, 3])\nprint(P)\n\n[ 1  5 -2  3]\n\n\nDie Auswertung des Polynoms an einem Punkt oder einem Array erfolgt mit der np.polyval-Funktion.\n\nx = 1\ny = np.polyval(P, x)\nprint(f\"P(x={x}) = {y}\")\n\nP(x=1) = 7\n\n\n\nx = np.array([-1, 0, 1])\ny = np.polyval(P, x)\nprint(f\"P(x={x}) = {y}\")\n\nP(x=[-1  0  1]) = [9 3 7]\n\n\nFür die graphische Darstellung im Bereich \\(x \\in [-6, 2]\\) können die bekannten numpy und matplotlib Funktionen verwendet werden.\n\nx = np.linspace(-6, 2, 50)\ny = np.polyval(P, x)\n\nplt.plot(x, y)\nplt.xlabel('x')\nplt.ylabel('y(x)')\nplt.grid()\n\n\n\n\n\n\n\n\nUm die Nullstellen eines Polynoms zu finden, kann die numpy-Funktion np.roots genutzt werden. Für das obige Polynom können folgende Nullstellen bestimmt werden.\n\nnstellen = np.roots(P)\n\n# direkte Ausgabe des Arrays\nprint(\"Nullstellen: \")\nprint(nstellen)\n\nNullstellen: \n[-5.46628038+0.j        0.23314019+0.703182j  0.23314019-0.703182j]\n\n\n\nprint(\"Nullstellen: \")\n# schönere Ausgabe des Arrays\nfor i, z in enumerate(nstellen):\n    if z.imag == 0:\n        print(f\"  x_{i+1} = {z.real:.2}\")\n    else:\n        print(f\"  x_{i+1} = {z.real:.2} {z.imag:+.2}i\")\n\nNullstellen: \n  x_1 = -5.5\n  x_2 = 0.23 +0.7i\n  x_3 = 0.23 -0.7i\n\n\nIn diesem Beispiel sind zwei der Nullstellen komplex. Eine komplexe Zahl \\(z\\) wird in Python als Summe des Realteils ($ Re\\() und Imaginärteils (\\) Im$). Letzterer wird durch ein nachfolgendes j, die imaginäre Einheit, gekennzeichnet.\n\\[ z = Re(z) + Im(z)j\\]\nDie Nullstellen können auch zur alternativen Darstellung des Polynoms verwendet werden. Sind \\(x_i\\) die \\(n\\) Nullstellen, so ist das Polynom \\(n\\)-ten Grades durch folgendes Produkt beschrieben:\n\\[ P(x) = \\prod_{i=1}^n \\left(x - x_i\\right) = (x - x_1)\\cdot (x - x_2) \\cdot \\cdots \\cdot (x - x_n) \\]\nSeien beispielsweise 1 und 2 die Nullstellen eines Polynoms, so lautet dieses:\n\\[  P(x) = (x - 1)(x - 2) = x^2 - 3x +2 \\]\nDie numpy-Funktion np.poly kann aus den Nullstellen die Polynomkoeffizienten bestimmen. Anhand des obigen Beispiels lautet der Funktionsaufruf:\n\nnstellen = [1, 2]\nkoeffizienten = np.poly(nstellen)\n\nprint(\"Nullstellen:\", nstellen)\nprint(\"Koeffizienten:\", koeffizienten)\n\nNullstellen: [1, 2]\nKoeffizienten: [ 1. -3.  2.]\n\n\nDas Modul numpy stellt viele praktische Funktionen zum Umgang mit Polynomen zur Verfügung. So existieren Funktionen um Polynome auszuwerten, die Nullstellen zu finden, zu addieren, zu multiplizieren, abzuleiten oder zu integrieren. Eine Übersicht ist in der numpy-Dokumentation gegeben.",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Interpolation – Lücken schließen</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/interpolation.html#interpolation",
    "href": "books/dataanalysis/interpolation.html#interpolation",
    "title": "23  Interpolation – Lücken schließen",
    "section": "23.3 Interpolation",
    "text": "23.3 Interpolation\nInterpolation ist eine Methode, um Datenpunkte zwischen gegebenen Messpunkten zu konstruieren. Dazu wird eine Funktion gesucht, die alle Messpunkte exakt abbildet, was gleichbedeutend damit ist, dass die L2-Norm zwischen Funktion und Punkten Null ist.\nZwei Punkte können z.B. mit einer Geraden interpoliert werden. D.h. für zwei Messpunktpaare \\((x_1, y_1)\\) und \\((x_2, y_2)\\) mit \\(x_1\\neq x_2\\) existiert ein Koeffizientensatz, sodass die L2-Norm zwischen den Messpunkten und der Modellfunktion\n\\[y(x) = \\beta_1 x + \\beta_0\\]\nverschwindet.\n\n# Beispieldaten aus y(x) = -x + 2\n\nN = 50\ndx = 0.25\n\ndef fnk(x):\n    return -x + 2\n\nx = np.array([1, 2])\ny = fnk(x)\n\nplt.scatter(x, y, color='C1', label=\"Messpunkte\", zorder=3)\n\nx_modell = np.linspace(np.min(x), np.max(x), N)\nplt.plot(x_modell, fnk(x_modell), color='C0', label=\"Modellfunktion\")\n\nx_linie = np.linspace(np.min(x)-dx, np.max(x)+dx, N)\nplt.plot(x_linie, fnk(x_linie), '--', alpha=0.3, color='C0')\n\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nFür drei Messpunkte muss ein Polynom zweiten Grades verwendet werden, um die Punkte exakt zu erfassen.\n\\[y(x) = \\beta_2 x^2 + \\beta_1 x + \\beta_0\\]\n\n# Beispieldaten aus y(x) = 3x^2 -4x - 1\n\nN = 50\ndx = 0.25\n\ndef fnk(x):\n    return 3*x**2-4*x - 1\n\nx = np.array([-1, 2, 3])\ny = fnk(x)\n\nplt.scatter(x, y, color='C1', label=\"Messpunkte\", zorder=3)\n\nx_modell = np.linspace(np.min(x), np.max(x), N)\nplt.plot(x_modell, fnk(x_modell), color='C0', label=\"Modellfunktion\")\n\nx_linie = np.linspace(np.min(x)-dx, np.max(x)+dx, N)\nplt.plot(x_linie, fnk(x_linie), '--', alpha=0.3, color='C0')\n\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nDies kann verallgemeinert werden: \\(n\\) Messpunkte können exakt mit einem Polynom ($ n-1$)-ten Grades abgebildet werden. Die Suche nach den passenden Koeffizienten ist das Lagrangesche Interpolationsproblem. Für das gesuchte Polynom \\(P(x)\\) gilt:\n\\[  P(x_i) = y_i \\quad i \\in 1, \\dots, n \\]\nDie Existenz und Eindeutigkeit eines solchen Polynoms kann gezeigt werden. Das gesuchte Polynom lautet:\n\\[  P(x) = \\sum_{i=1}^n y_i I_i(x) \\] \\[  \\text{mit}\\quad I_i(x) = \\prod_{j=1, i\\neq j}^n \\frac{x-x_j}{x_i - x_j} \\]\nAlternativ kann auch ein Gleichungssystem, welches durch die Polynomialbasis \\(\\phi_i(x)\\) gegeben ist, gelöst werden. Für die \\(n\\) Punktepaare gilt jeweils:\n\\[  y(x_i) = \\sum_{i=1}^{m}\\beta_i \\cdot \\phi_i(x_i) = \\beta_1\\cdot \\phi_1(x_i) + \\cdots + \\beta_m\\cdot \\phi_m(x_i) = y_i \\]\nDas allgemeine Geleichungssystem lautet\n\\[  \\left( \\begin{matrix} \\phi_1(x_1) & \\phi_2(x_1) & \\cdots & \\phi_m(x_1) \\\\\n             \\phi_1(x_2) & \\phi_2(x_2) & \\cdots & \\phi_m(x_2) \\\\\n             \\vdots &\\vdots & \\ddots & \\vdots \\\\\n             \\phi_1(x_n) & \\phi_2(x_n) & \\cdots & \\phi_m(x_n) \\\\\n             \\end{matrix}\\right).\n\\left(  \\begin{matrix} \\beta_1 \\\\  \n      \\beta_2 \\\\   \\vdots \\\\   \\beta_m \\\\\n      \\end{matrix} \\right)\n= \\left(  \\begin{matrix} y_1 \\\\  y_2 \\\\   \\vdots \\\\   y_n \\\\ \\end{matrix} \\right) \\]\nund mit der Polynomialbasis\n\\[ \\underbrace{\\left( \\begin{matrix} 1 & x_1 & \\cdots & x_1^{n-1} \\\\ 1 & x_2 & \\cdots & x_2^{n-1} \\\\ \\vdots &\\vdots & \\ddots & \\vdots \\\\ 1 & x_n & \\cdots & x_n^{n-1} \\\\ \\end{matrix}\\right)}_{V}. \\left(  \\begin{matrix} \\beta_1 \\\\  \\beta_2 \\\\   \\vdots \\\\   \\beta_m \\\\ \\end{matrix} \\right) = \\left(  \\begin{matrix} y_1 \\\\  y_2 \\\\   \\vdots \\\\   y_n \\\\ \\end{matrix} \\right)\\]\nDie Matrix \\(V\\) heisst Vandermonde-Matrix und kann exakt gelöst werden, für \\(m=n\\) und wenn für alle \\(i, j, i\\neq j\\) gilt \\(x_i \\neq x_j\\).\nIn Python kann das Interpolationsproblem mit der Funktion np.polyfit gelöst werden. Das folgende Beispiel demonstriert deren Anwendung.\nDie Messtellen folgen in dem Beispiel der Funktion \\(f(x)\\), welche nur zur Generierung der Datenpunkte verwendet wird.\n\\[ f(x) = \\frac{1}{2} + \\frac{1}{1+x^2}\\]\nZunächst werden die Messpunkte generiert.\n\ndef fnk(x):\n    return 0.5 + 1/(1+x**2)\n\n\nxmin = -5\nxmax =  5\nx = np.linspace(xmin, xmax, 100)\ny = fnk(x)\n\n\nn = 5\nxi = np.linspace(xmin, xmax, n)\nyi = fnk(xi)\n\nNun folgt die Interpolation für 5 und 15 Messpunkte.\n\nP = np.polyfit(xi, yi, n-1)\nprint(\"Interpolationskoeffizienten:\")\nprint(P)\n\nInterpolationskoeffizienten:\n[ 5.30503979e-03  4.23767299e-17 -1.71087533e-01  7.45353051e-16\n  1.50000000e+00]\n\n\n\nplt.plot(x, y, color='C0', alpha=0.5, label='generierende Funktion')\nplt.plot(x, np.polyval(P, x), color='C2', label='Interpolation')\nplt.scatter(xi, yi, color='C1', label='Messpunkte', zorder=3)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\n\nn = 15\nxi = np.linspace(xmin, xmax, n)\nyi = fnk(xi)\n\nP = np.polyfit(xi, yi, n-1)\n\nplt.plot(x, y, color='C0', alpha=0.5, label='generierende Funktion')\nplt.plot(x, np.polyval(P, x), color='C2', label='Interpolation')\nplt.scatter(xi, yi, color='C1', label='Messpunkte', zorder=3)\nplt.legend()\nplt.grid()\n\n\n\n\n\n\n\n\nDie Interpolation erfüllt immer die geforderte Bedingung \\(y(x_i) = y_i\\). Jedoch führen Polynome mit einem hohen Grad oft zu nicht sinnvollen Ergebnissen. Es entstehen starke Überschwinger, welche mit zunehmendem Grad immer stärker werden. Eine alternative Interpolationsmethode stellen Splines dar, welche mehrere, niedrige Polynome zur Interpolation vieler Punkte verwenden.",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Interpolation – Lücken schließen</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/fitting.html",
    "href": "books/dataanalysis/fitting.html",
    "title": "24  Fitting",
    "section": "",
    "text": "Beim Fitting wird eine Modellfunktion gesucht, weche die Messdaten nicht unbedingt exakt abbildet. Wird ein Polynom verwendet, so hat es eine Grad, welcher deutlich kleiner ist, als die Anzahl der Messpunkte. Lineare Regression ist ein Beispiel für ein Fitting durch ein Polynom mit dem Grad Eins.\nZum Fitten durch ein Polynom kann die Funktion np.polyfit verwendet werden, genauso wie bei der Polynominterpolation. Diesmal jedoch mit einem kleineren Polynomgrad.\nIm folgenden Beispiel werden zunächst Modelldaten generiert und dann mit entsprechenden Polynomen gefittet.\n\nxmin = 0\nxmax = 5\nx = np.linspace(xmin, xmax, 100)\n\nni = 25\n\n# x-Werte mit leichtem Rauschen\nxi = np.linspace(xmin, xmax, ni) + 0.2*(2 * np.random.random(ni) -1)\n\n# y(x) = 2x+0.5 mit leichtem Rauschen\nyi = 2*xi + 0.5 + 2*(2 * np.random.random(ni) -1)\n\nplt.scatter(xi, yi, color='C1')\nplt.grid()\n\n\n\n\n\n\n\n\n\nP1 = np.polyfit(xi, yi, 1)\n\nplt.scatter(xi, yi, color='C1', zorder=3, label='Messpunkte')\nplt.plot(x, np.polyval(P1, x), color='C0', label=\"Modellfunktion\")\nplt.grid()\nplt.legend()\n\n\n\n\n\n\n\n\n\n# x-Werte mit leichtem Rauschen\nxi = np.linspace(xmin, xmax, ni) + 0.2*(2 * np.random.random(ni) -1)\n\n# y(x) = 2x+0.5 mit leichtem Rauschen\nyi = (xi - 2)**2 -2*xi + 2.5 + 2*(2 * np.random.random(ni) -1)\n\n\nP1 = np.polyfit(xi, yi, 1)\nP2 = np.polyfit(xi, yi, 2)\n\nplt.scatter(xi, yi, color='C1', zorder=3, label='Messpunkte')\nplt.plot(x, np.polyval(P1, x), color='C0', label=\"Modellfunktion, Grad 1\")\nplt.plot(x, np.polyval(P2, x), color='C2', label=\"Modellfunktion, Grad 2\")\nplt.grid()\nplt.legend()\nplt.show()",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Fitting</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/splines.html",
    "href": "books/dataanalysis/splines.html",
    "title": "25  Splines",
    "section": "",
    "text": "25.1 Definition\nPolynominterpolation versucht eine globale Modellfunktion zu finden. Jedoch eignen sich Polynome mit hohen Graden im Allgemeinen nicht für eine Interpolation vieler Punkte. Einen anderen Ansatz verfolgen Splines. Diese sind Polynomzüge, welche die einzelnen Messpunkte verbinden und deren Grad klein – typischerweise zwischen eins und drei – ist.\nFür \\(n+1\\) Messpunkte \\((x_i, y_i)\\) kann eine Splinefunktion \\(s_k\\), hier ein Polynomspline, wie folgt definiert werden.\nBeispiele: * \\(k = 1\\): Polygonzug * \\(k = 3\\): kubische Polynomsplines (B-Splines)",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Splines</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/splines.html#definition",
    "href": "books/dataanalysis/splines.html#definition",
    "title": "25  Splines",
    "section": "",
    "text": "Vorausgesetzt ist, dass die Messpunkte sortiert sind, d.h. \\(x_0 &lt; x_1 &lt; \\cdots &lt; x_n\\)\nfür jedes \\(i = 0\\dots n − 1\\) ist \\(s_k\\) ein Polynom vom Grad \\(k\\) auf dem Intervall \\(\\left[x_i , x_{i+1}\\right]\\)\n\\(s_k\\) ist auf \\(\\left[x_0 , x_n \\right]\\) \\((k − 1)\\)-mal stetig differenzierbar",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Splines</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/splines.html#kubische-splines",
    "href": "books/dataanalysis/splines.html#kubische-splines",
    "title": "25  Splines",
    "section": "25.2 Kubische Splines",
    "text": "25.2 Kubische Splines\nDie in der Praxis häufig eingesetzten kubischen Polynomsplines \\(s_3\\) ($ k= 3$) haben folgende Eigenschaften: * \\(s_3|\\left[x_i,x_{i+1}\\right] = \\beta_0 +\\beta_1 x + \\beta_2 x^2 + \\beta_3 x^3\\) * \\(s_3\\) ist zweimal stetig differenzierbar auf \\(\\left[x_0,x_n\\right]\\), also insbesondere an den Stützpunkten \\(x_i\\) der Messpunkte\nDie Koeffizienten \\(\\beta_i\\) werden wie folgt bestimmt * aus den \\(n + 1\\) Messpunkten ergeben sich \\(n\\) Intervalle, d.h. mit jeweils vier Koeffizienten sind es insgesamt \\(4n\\) Koeffizienten * Exakte Darstellung der Messpunkte ($ n + 1$ Gleichungen), d.h.: \\(s_3(x_i) = y_i\\) * Glattheitsbedingungen an den inneren Messpunkten ($ i=1n-1\\(), mit jeweils (\\) n − 1$ Gleichungen): \\[ s_3'(x_i)_- =s_3'(x_i)_+\\] \\[ s_3''(x_i)_- =s_3''(x_i)_+\\] \\[ s_3'''(x_i)_- =s_3'''(x_i)_+\\]\n\nDamit sind es \\(4n − 2\\) Gleichungen für \\(4n\\) Koeffizienten\n\nUm die beiden fehlenden Gleichungen zu finden bzw. zu bestimmen werden Randbedingungen oder Abschlussbedingungen benötigt. Die gängigsten Bedingungen sind: * natürliche Splines: die Krümung am Rand verschwindet, d.h.: \\[ s_3''(x_0) = s_3''(x_n) = 0 \\] * periodische Splines: die Steigung und Krümung ist an beiden Rändern gleich \\[ s_3'(x_0) = s_3'(x_n)\\] \\[ s_3''(x_0) = s_3''(x_n)\\] * Hermite Splines: die Steigungen am Rand werden explizit vorgegeben (hier durch \\(u\\) und \\(v\\)) \\[ s_3'(x_0) = u \\] \\[ s_3'(x_n) = v \\]",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Splines</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/splines.html#anwendung",
    "href": "books/dataanalysis/splines.html#anwendung",
    "title": "25  Splines",
    "section": "25.3 Anwendung",
    "text": "25.3 Anwendung\nIm Folgenden werden zwei Beispiele, \\(s_1\\) und \\(s_3\\), für die Erstellung von Splines mit Python vorgestellt.\n\n# Erzeugung von Messpunkten\nn = 7\nxi = np.linspace(0, np.pi, n)\nyi = np.sin(xi)\n\nFür die \\(s_1\\) Splines, kann die Funktion np.interp verwendet werden. Sie führt eine lineare Interpolation zwischen gegebenen Wertepaaren durch.\n\n# Wertebereich für die Visualisierung der Interpolation\nx = np.linspace(0, np.pi, n*6)\ny = np.sin(x)\n\n\n# Interpolation\ny_s1 = np.interp(x, xi, yi)\n\n\nplt.plot(x,y, alpha=0.3, color='C2', lw=5, \n         label='Generierende Funktion')\nplt.plot(x, y_s1, color='C0', label='Interpolation')\nplt.scatter(x, y_s1, s=3, zorder=3, color='C0')\nplt.scatter(xi, yi, color='C1', label='Messpunkte')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend();\n\n\n\n\n\n\n\n\nDie \\(s_3\\) Splines können mit Funktionen aus dem scipy-Modul berechnet werden. Dazu werden zunächst die Koeffizienten bestimmt (scipy.interpolate.splrep) und diese ermöglichen die gewünschte Auswertung, welche mit der Funktion scipy.interpolate.splev vorgenommen werden kann.\n\nimport scipy.interpolate as si\n\n\ns3 = si.splrep(xi, yi)\ny_s3 = si.splev(x, s3)\n\n\nplt.plot(x,y, alpha=0.3, color='C2', lw=5, \n         label='Generierende Funktion')\nplt.plot(x, y_s3, color='C0', label='Interpolation')\nplt.scatter(x, y_s3, s=3, zorder=3, color='C0')\nplt.scatter(xi, yi, color='C1', label='Messpunkte')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend();",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Splines</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/glaetten.html",
    "href": "books/dataanalysis/glaetten.html",
    "title": "26  Trendglättung – Rauschen reduzieren",
    "section": "",
    "text": "Verrauschte Daten? Ein gleitender Mittelwert glättet Kurven:\n\ndata = np.genfromtxt(\"trenddaten_mit_rauschen.csv\", delimiter=\",\", skip_header=1)\nx = data[:, 0]\ny = data[:, 1]\n\nwindow = 5\nweights = np.ones(window) / window\ny_smooth = np.convolve(y, weights, mode='valid')\n\nplt.plot(x, y, label=\"Original\", alpha=0.5)\nplt.plot(x[(window-1)//2:-(window//2)], y_smooth, label=\"Geglättet\", color='red')\nplt.legend()\nplt.grid(True)\nplt.title(\"Trendglättung\")\nplt.show()",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Trendglättung – Rauschen reduzieren</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/anwendungsbeispiel.html",
    "href": "books/dataanalysis/anwendungsbeispiel.html",
    "title": "27  Anwendungsbeispiele",
    "section": "",
    "text": "27.1 Anwendung: Ballonfahrt-Daten analysieren\nballon = np.genfromtxt(\"messdaten_ballonfahrt.txt\", delimiter=\",\", skip_header=1)\nzeit = ballon[:, 0]\nhoehe = ballon[:, 1]\n\nplt.plot(zeit, hoehe)\nplt.title(\"Ballonfahrt – Höhe über Zeit\")\nplt.xlabel(\"Zeit (s)\")\nplt.ylabel(\"Höhe (m)\")\nplt.grid(True)\nplt.show()\n\ngeschwindigkeit = np.gradient(hoehe, zeit)\nplt.plot(zeit, geschwindigkeit, color=\"orange\")\nplt.title(\"Geschwindigkeit\")\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Anwendungsbeispiele</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/anwendungsbeispiel.html#anwendung-balkenverformung-im-bauingenieurwesen",
    "href": "books/dataanalysis/anwendungsbeispiel.html#anwendung-balkenverformung-im-bauingenieurwesen",
    "title": "27  Anwendungsbeispiele",
    "section": "27.2 Anwendung: Balkenverformung im Bauingenieurwesen",
    "text": "27.2 Anwendung: Balkenverformung im Bauingenieurwesen\nEin Träger wird in der Mitte belastet. Die Durchbiegung wird an 50 Punkten gemessen:\n\nbalken = np.genfromtxt(\"balken_durchbiegung.csv\", delimiter=\",\", skip_header=1)\nx = balken[:, 0]\ny = balken[:, 1]\n\nwindow = 7\nweights = np.ones(window) / window\ny_smooth = np.convolve(y, weights, mode='valid')\n\nplt.plot(x, y, label=\"Messung\", alpha=0.5)\nplt.plot(x[(window-1)//2:-(window//2)], y_smooth, label=\"Geglättet\", color='red')\nplt.title(\"Durchbiegung eines Trägers\")\nplt.xlabel(\"Position (m)\")\nplt.ylabel(\"Durchbiegung (mm)\")\nplt.legend()\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Anwendungsbeispiele</span>"
    ]
  },
  {
    "objectID": "books/dataanalysis/anwendungsbeispiel.html#zusammenfassung",
    "href": "books/dataanalysis/anwendungsbeispiel.html#zusammenfassung",
    "title": "27  Anwendungsbeispiele",
    "section": "27.3 Zusammenfassung",
    "text": "27.3 Zusammenfassung\nIn dieser Einheit haben Sie gelernt:\n\nwie Daten eingelesen und bereinigt werden,\nwie man sie analysiert und visualisiert,\nwie Interpolation und Glättung funktionieren,\nwie reale Datensätze aus Technik und Naturwissenschaft ausgewertet werden können.\n\nDiese Fähigkeiten sind grundlegend für jede datengetriebene Analyse im Ingenieurbereich.",
    "crumbs": [
      "Datenanalyse und Modellierung",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Anwendungsbeispiele</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/introduction.html",
    "href": "books/a-algorithmen/skript/introduction.html",
    "title": "Algorithmen",
    "section": "",
    "text": "Einführung",
    "crumbs": [
      "Algorithmen"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/introduction.html#definition",
    "href": "books/a-algorithmen/skript/introduction.html#definition",
    "title": "Algorithmen",
    "section": "Definition",
    "text": "Definition\nEin Algorithmus ist eine formale Vorschrift darüber, wie die Lösung einer Fragestellung gefunden werden kann. Dabei handelt es sich meist um eine Folge von einfachen Anweisungen, welche zur Lösung komplexer Probleme führen kann.\n\n\n\nAlgorithmus\n\n\nAlgorithmen sollten so formuliert sein, dass sie nicht nur für einzelne explizite Fragestellungen, sondern auch im Allgemeinen anwendbar sind. Das wird am Beispiel des schriftliche Dividierens oder anhand eines Kuchenrezepts deutlich. Beide bestehen aus einfachen Anweisungen und lösen ein komplexeres Problem. Allerdings kann die Rechenvorschrift für beliebige Divisionsaufgaben eingesetzt werden, während das Kuchenrezept nur zur Herstellung eines speziellen Kuchens führt.\nDie obigen Beispiele für einen Algorithmus sind zwei von vielen, welche von Menschen eingesetzt werden (können):\n\nSchriftliches Rechnen\nLösen von linearen Gleichungssystemen\nBestimmung des Durchschnitts\nLösen eines Zauberwürfels\n\nViele Algorithmen aus unserem Alltag sind aus sehr elementaren Anweisungen aufgebaut. Trotz der Einfachheit der Anweisungen, können sie von Menschen nicht eingesetzt werden, da die erforderliche Anzahl von Operationen sehr hoch sein kann. An dieser Stelle kommen Computer zum Einsatz. Wie in diesem Kapitel gezeigt wird, können mit den Grundrechenarten und Logischen Verknüpfungen komplexe Probleme gelöst werden.",
    "crumbs": [
      "Algorithmen"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/introduction.html#beispiele",
    "href": "books/a-algorithmen/skript/introduction.html#beispiele",
    "title": "Algorithmen",
    "section": "Beispiele",
    "text": "Beispiele\nBeispiele für Algorithmen aus dem Alltag bzw. Ingenieurwesen, welche auf Computer zurückgreifen:\n\nNumerische Lösung von Differentialgleichungen (z.B. Strukturmechanik, Wärmetransport)\nSuchmaschinen im Internet\nVorschläge beim online Einkaufen oder Medienkonsum\nAutonavigation",
    "crumbs": [
      "Algorithmen"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/umsetzung.html",
    "href": "books/a-algorithmen/skript/umsetzung.html",
    "title": "28  Von der Idee zum Code",
    "section": "",
    "text": "28.1 Kapitelübersicht\nEin einfacher Algorithmus zur Bestimmung des maximalen Werts einer beliebig großen Menge von Zahlen ist wie folgt definiert:\nDieser Algorithmus mag Ihnen auf den ersten Blick kompliziert. Gehen wir nochmal einen Schritt zurück und schauen uns einen Algorithmus an den wir bereits kennengelernt haben: Prüfen ob eine Zahl gerade ist.\nDiesen Auflistung können wir uns besser visualisieren. Dazu benutzen wir sogenannte Flussdiagramme.\nFlussdiagramme sind nicht der einzige Weg, um komplexere Algorithmen verständlicher aufzuschreiben. Eine weitere Möglichkeit bieter hier sogenannter Pseudocode:\nKommen wir nun zu dem “komplexeren Algorithmus zurück, der das Maximum in einer Liste von Zahlen finden soll:\nTesten Sie einmal selbst, ob Sie das passende Flussdiagramm erstellen können. In der folgenden Box finden Sie die Musterlösung. Sie brauchen hierfür auch die Verzweigung für Schleifen: Verzweigung (blau): Abfrage einer Bedingung, welche entscheidet welche folgenden Elemente ausgeführt werden, hier wird geprüft ob \\(\\mathsf a &gt; m\\)\nWie oben beschrieben, können wir aber nicht nur Flussdiagramme zur Darstellung von Algorithmen nutzen, sondern auch sogenannten Pseudocode. Versuchen Sie einmal selbst den ALgorithmus zur Maximumsuche in Pseudocode zu formulieren.\nEin Beispiel für den Ablauf des Algoritmus für eine Liste von 20 Zahlen ist:\nIn diesem Kapitel werden folgende Themen behandelt:",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Von der Idee zum Code</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/umsetzung.html#kapitelübersicht",
    "href": "books/a-algorithmen/skript/umsetzung.html#kapitelübersicht",
    "title": "28  Von der Idee zum Code",
    "section": "",
    "text": "Sortieralgorithmen\nEigenschaften von Algorithmen\nNumerische Algorithmen",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Von der Idee zum Code</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/sortieralgorithmen.html",
    "href": "books/a-algorithmen/skript/sortieralgorithmen.html",
    "title": "29  Sortieralgorithmen",
    "section": "",
    "text": "29.1 Selectionsort\nSortieralgoritmen werden genutzt um Listen von Werten der Größe nach zu sortieren. Anwendung finden diese Algorithmen bei Datenbanken oder Suchvorgängen. Insbesondere bei langen Listen mit Millionen oder Milliarden Einträgen ist es wichtig, dass der Algorithmus mit möglichst wenigen Operationen pro Element auskommt. Diese, als Komplexität bezeichnete Eigenschaft, wird im nächsten Kapitel genauer erläutert.\nZunächst werden zwei einfache Sortieralgorithmen\nvorgestellt. Diese werden in der Praxis kaum noch eingesetzt, da es eine Vielzahl anderer Sortierverfahren gibt, welche effektiver arbeiten. Jedoch eignen sich diese beiden besonders gut, um die Grundideen zu verdeutlichen.\nFolgende Grundidee liegt dem Selectionsort zugrunde: Es wird der minimale Wert der Liste gesucht, dann der zweit-kleinste und so weiter bis die ganze Liste sortiert ist. Dies kann als Abfolge dieser Schritte für eine Liste mit \\(\\mathsf n\\) Elementen formalisiert werden.\nDer Selectionsort kann auch als folgendes Flussdiagramm dargestellt werden.\nAls Zahlenbeispiel wird die Liste mit den Elementen 42, 6, 22, 11, 54, 12, 31 mit dem Selectionsort sortiert.\nA = [42, 6, 22, 11, 54, 12, 31]\n\nprint('Zu sortierende Werteliste ', A)\nprint()\n\nn = len(A)\nfor i in range(n):\n    mv = A[i]\n    mi = i\n    for j in range(i, n):\n        if A[j] &lt; mv:\n            mv = A[j]\n            mi = j\n\n    print(\"Iteration {:2d}: \".format(i+1))\n    print(\"   Minimum von \", A[i:n], \"ist\", mv)\n    A[mi] = A[i]\n    A[i] = mv\n    print(\"   Sortiert / Unsortiert: \", A[:i+1], \"/\", A[i+1:])\n    print()\n\nZu sortierende Werteliste  [42, 6, 22, 11, 54, 12, 31]\n\nIteration  1: \n   Minimum von  [42, 6, 22, 11, 54, 12, 31] ist 6\n   Sortiert / Unsortiert:  [6] / [42, 22, 11, 54, 12, 31]\n\nIteration  2: \n   Minimum von  [42, 22, 11, 54, 12, 31] ist 11\n   Sortiert / Unsortiert:  [6, 11] / [22, 42, 54, 12, 31]\n\nIteration  3: \n   Minimum von  [22, 42, 54, 12, 31] ist 12\n   Sortiert / Unsortiert:  [6, 11, 12] / [42, 54, 22, 31]\n\nIteration  4: \n   Minimum von  [42, 54, 22, 31] ist 22\n   Sortiert / Unsortiert:  [6, 11, 12, 22] / [54, 42, 31]\n\nIteration  5: \n   Minimum von  [54, 42, 31] ist 31\n   Sortiert / Unsortiert:  [6, 11, 12, 22, 31] / [42, 54]\n\nIteration  6: \n   Minimum von  [42, 54] ist 42\n   Sortiert / Unsortiert:  [6, 11, 12, 22, 31, 42] / [54]\n\nIteration  7: \n   Minimum von  [54] ist 54\n   Sortiert / Unsortiert:  [6, 11, 12, 22, 31, 42, 54] / []",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sortieralgorithmen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/sortieralgorithmen.html#selectionsort",
    "href": "books/a-algorithmen/skript/sortieralgorithmen.html#selectionsort",
    "title": "29  Sortieralgorithmen",
    "section": "",
    "text": "Wiederhole die Schritte 2 bis 4 \\(\\mathsf n\\) Mal. Setzte die Hilfsvariable \\(i\\) initial auf Null.\nSuche den minimalen Wert der Liste ab dem \\(\\mathsf i\\)-ten Element.\nTausche dieses Element mit dem \\(\\mathsf i\\)-ten Element.\nErhöhe den Wert von \\(\\mathsf i\\) um Eins.\nDie Vertauschungen der Elemente haben zu einer sortierten Liste geführt.\n\n\n\n\n\nFlussdiagramm des Selectionsort",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sortieralgorithmen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/sortieralgorithmen.html#bubblesort",
    "href": "books/a-algorithmen/skript/sortieralgorithmen.html#bubblesort",
    "title": "29  Sortieralgorithmen",
    "section": "29.2 Bubblesort",
    "text": "29.2 Bubblesort\nIm Gegensatz zum Selectionsort beruht die Idee des Bubblesort auf rein lokalen Operationen. D.h. hier wird nicht nach den maximalen Werten gesucht, sondern durch Vertauschungen eine Sortierung erzielt. Das Verfahren für eine Liste mit \\(\\mathsf n\\) Elementen ist durch folgende Vorschrift gegeben.\n\nDie Schritte 2 bis 4 werden \\(\\mathsf n\\) Mal durchgeführt. Die Hilfsvariable \\(\\mathsf i\\) wird initial auf Null gesetzt.\nStarte beim \\(\\mathsf i\\)-ten Element und iteriere bis zum Ende der Liste. Falls das aktuell betrachtete Element größer ist als das Folgende, tausche beide Elemente.\nFalls in Schritt 2 keine Vertauschungen durchgeführt wurden, gehe zu Schritt 5.\nAddiere Eins zum Wert der Variable \\(\\mathsf i\\).\nDie Liste ist sortiert und der Algorithmus ist fertig.\n\nDas nachfolgende Flussdiagramm verdeutlicht den Ablauf des Bubblesort Algorithmus. Bevor Sie sich das Diagram anschauen, versuchen Sie es einmal selbst zu erstellen.\n\n\n\n\n\n\nFlussdiagramm: Bubblesort\n\n\n\n\n\n\n\n\nFlussdiagramm des Bubblesort\n\n\n\n\n\nDer Ablauf des Bubblesort wird beispielhaft für die Liste 42, 6, 22, 11, 54, 12, 31 (gleich der im obigen Beispiel) vorgeführt.\n\nA = [42, 6, 22, 11, 54, 12, 31]\n\nprint('Zu sortierende Werteliste ', A)\nprint()\n\nn = len(A)\nswapped = True\ni = 0\nwhile swapped:\n    swapped = False\n    print(\"Iteration {:2d}: \".format(len(A) - n + 1))\n    print(\"   Liste zu Beginn der Iteration: \", A)\n    for j in range(n-1):\n        if A[j+1] &lt; A[j]:\n            print(\"   Tausche: \", A[j], \"und\", A[j+1])\n            mv = A[j]\n            A[j] = A[j+1]\n            A[j+1] = mv\n            print(\"   Liste nach Tausch: \", A)\n            swapped = True\n        else:\n            print(\"   Elemente \", A[j], \"und\", A[j+1], \" müssen nicht getauscht werden\")\n    n -= 1\n    if not swapped:\n        print(\"   kein Tausch mehr notwendig, Liste ist nun sortiert\")\n    print()\n\nZu sortierende Werteliste  [42, 6, 22, 11, 54, 12, 31]\n\nIteration  1: \n   Liste zu Beginn der Iteration:  [42, 6, 22, 11, 54, 12, 31]\n   Tausche:  42 und 6\n   Liste nach Tausch:  [6, 42, 22, 11, 54, 12, 31]\n   Tausche:  42 und 22\n   Liste nach Tausch:  [6, 22, 42, 11, 54, 12, 31]\n   Tausche:  42 und 11\n   Liste nach Tausch:  [6, 22, 11, 42, 54, 12, 31]\n   Elemente  42 und 54  müssen nicht getauscht werden\n   Tausche:  54 und 12\n   Liste nach Tausch:  [6, 22, 11, 42, 12, 54, 31]\n   Tausche:  54 und 31\n   Liste nach Tausch:  [6, 22, 11, 42, 12, 31, 54]\n\nIteration  2: \n   Liste zu Beginn der Iteration:  [6, 22, 11, 42, 12, 31, 54]\n   Elemente  6 und 22  müssen nicht getauscht werden\n   Tausche:  22 und 11\n   Liste nach Tausch:  [6, 11, 22, 42, 12, 31, 54]\n   Elemente  22 und 42  müssen nicht getauscht werden\n   Tausche:  42 und 12\n   Liste nach Tausch:  [6, 11, 22, 12, 42, 31, 54]\n   Tausche:  42 und 31\n   Liste nach Tausch:  [6, 11, 22, 12, 31, 42, 54]\n\nIteration  3: \n   Liste zu Beginn der Iteration:  [6, 11, 22, 12, 31, 42, 54]\n   Elemente  6 und 11  müssen nicht getauscht werden\n   Elemente  11 und 22  müssen nicht getauscht werden\n   Tausche:  22 und 12\n   Liste nach Tausch:  [6, 11, 12, 22, 31, 42, 54]\n   Elemente  22 und 31  müssen nicht getauscht werden\n\nIteration  4: \n   Liste zu Beginn der Iteration:  [6, 11, 12, 22, 31, 42, 54]\n   Elemente  6 und 11  müssen nicht getauscht werden\n   Elemente  11 und 12  müssen nicht getauscht werden\n   Elemente  12 und 22  müssen nicht getauscht werden\n   kein Tausch mehr notwendig, Liste ist nun sortiert",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>Sortieralgorithmen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/eigenschaften.html",
    "href": "books/a-algorithmen/skript/eigenschaften.html",
    "title": "30  Eigenschaften",
    "section": "",
    "text": "30.1 Terminiertheit\nTerminiertheit bedeutet, dass ein Algorithmus nach endlich vielen Schritten anhält, oder er bricht kontrolliert ab. Einfache Beispiele:\nAllerdings kann die Terminiertheit nicht für alle Algerithmen gezeigt werden. Das Halteproblem besagt, dass es gibt keinen Verfahren gibt, welches immer zutreffend sagen kann, ob der Algorithmus für die Eingabe terminiert. Hierzu kann das Collatz-Problem als Beispiel herangezogen werden.\nDie Zahlenfolge wird wie folgt konstruiert:\nCollatz-Vermutung: Jede so konstruierte Zahlenfolge mündet in den Zyklus 4, 2, 1, egal, mit welcher natürlichen Zahl man beginnt. Bisher unbewiesen.",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Eigenschaften</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/eigenschaften.html#terminiertheit",
    "href": "books/a-algorithmen/skript/eigenschaften.html#terminiertheit",
    "title": "30  Eigenschaften",
    "section": "",
    "text": "Addition zweier Dezimalzahlen\nSumme der ersten N natürlichen Zahlen\n\n\n\n\nbeginne mit irgendeiner natürlichen Zahl \\(\\mathsf n_0 &gt; 0\\)\nist \\(\\mathsf n_i\\) gerade so ist \\(\\mathsf n_{i+1} = n_i/2\\)\nist \\(\\mathsf n_i\\) ungerade so ist \\(\\mathsf n_{i+1} = 3n_i + 1\\)\nendet bei \\(\\mathsf n_i = 1\\)",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Eigenschaften</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/eigenschaften.html#determiniertheit",
    "href": "books/a-algorithmen/skript/eigenschaften.html#determiniertheit",
    "title": "30  Eigenschaften",
    "section": "30.2 Determiniertheit",
    "text": "30.2 Determiniertheit\nEin deterministischer Algorithmus ist ein Algorithmus, bei dem nur definierte und reproduzierbare Zustände auftreten. Die Ergebnisse des Algorithmus sind somit immer reproduzierbar. Beispiele hierfür:\n\nAddition ganzer Zahlen\nSelectionsort\nCollatz-Sequenz",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Eigenschaften</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/eigenschaften.html#effizienz",
    "href": "books/a-algorithmen/skript/eigenschaften.html#effizienz",
    "title": "30  Eigenschaften",
    "section": "30.3 Effizienz",
    "text": "30.3 Effizienz\nDie Effizienz eines Algorithmus ist nicht strikt definiert und kann folgende Aspekte umfassen:\n\nLaufzeit\nSpeicheraufwand\nEnergieverbrauch\n\nBei bestimmten Anwendungen sind entsprechende Eigenschaften notwendig:\n\nSpeicheraufwand bei Big Data, also riesige Datenmengen, z.B. in der Bioinformatik\nLaufzeit bei Echtzeitanwendung, z.B. Flugzeugsteuerung, Fußgängerdynamik",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Eigenschaften</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/eigenschaften.html#komplexität",
    "href": "books/a-algorithmen/skript/eigenschaften.html#komplexität",
    "title": "30  Eigenschaften",
    "section": "30.4 Komplexität",
    "text": "30.4 Komplexität\nBei der Analyse von Algorithmen, gilt es die Komplexiät zu bestimmen, welche ein Maß für den Aufwand darstellt. Dabei wird nach einer Aufwandfunktion \\(\\mathsf f(n)\\) gesucht, welche von der Problemgröße \\(\\mathsf n\\) abhängt. Beispiel für eine Problemgröße:\n\nAnzahl der Summanden bei einer Summe\nAnzahl der zu sortierenden Zahlen\n\nMeist wird dabei die Bestimmung auf eine asymptotische Analyse, d.h. eine einfache Vergleichsfunktion \\(\\mathsf g(n)\\) mit \\(\\mathsf n \\rightarrow \\infty\\), reduziert. Dabei beschränkt \\(\\mathsf g(n)\\) das Wachstum von \\(\\mathsf f(n)\\).\nDie Funktion \\(\\mathsf g(n)\\) wird oft durch ein \\(\\mathcal{O}\\) gekennzeichnet und gibt so eine möglichst einfache Vergleichsfunktion an. Beispiele:\n\n\\(\\mathsf f_1(n) = n^4 + 5n^2 - 10 \\approx \\mathcal{O}(n^4) = g_1(n)\\)\n\\(\\mathsf f_2(n) = 2^{n+1} \\approx \\mathcal{O}(2^n) = g_2(n)\\)\n\n\n\n\nKomplexität eines Algorithmus durch Vergleich einer Aufwandfunktion mit einer Vergleichsfunktion\n\n\nUm sich ein besseres Bild zu den Auswirkungen hoher Kompexitäten zu machen, sei folgendes Beispiel gegeben.\n\nein Berechnungsschritt (unabhängig von der Problemgröße \\(\\mathsf n\\)) sei z.B. 1 s lang\ndas \\(\\mathsf n\\) sei beispielsweise 1000\n\nDamit ergeben sich folgende (asymptotische) Abschätzungen der Laufzeit:\n\n\\(\\mathcal{O}(n)\\): 103 s ≈ 1 h\n\\(\\mathcal{O}(n^2)\\): 106 s ≈ 11 d\n\\(\\mathcal{O}(n^3)\\): 109 s ≈ 31 a\n\\(\\mathcal{O}(2^n)\\): 21000 s ≈ …\n\n\n30.4.1 Komplexität Selectionsort\nDie Kompexität dieses Verfahrens kann leicht abgeschätzt werden. Bei jedem Durchlauf wir das Minimum / Maximum gesucht, was anfangs \\(\\mathsf n\\) Operationen benötigt. Beim nächsten Durchlauf sind es nur noch \\(\\mathsf n − 1\\) Operationen und so weiter. In der Summe sind es also\n\\[ \\mathsf f(n) = \\sum_{i=0}^n i = \\frac{n(n-1)}{2} \\approx \\mathcal{O}(n^2) \\]\nDamit hat der Selectionsort eine Komplexität von \\(\\mathcal{O}(n^2)\\). Die folgende Abbildung verdeutlicht dies nochmals.\n\n\n10 41.989\n20 180.766\n30 419.547\n40 757.118\n50 1193.255\n60 1732.344\n70 2365.573\n80 3104.131\n90 3941.413\n100 4881.544\n\n\n\n\n\nAbschätzung der Koplexität des Selectionsort-Algorithmus\n\n\n\n\n30.4.2 Komplexität Bubblesort\nDie Komplexität des Bubblesort muss unterschieden werden in den günstigsten Fall (best case), den ungünstigsten Fall (worst case) und einem durchschnittlichen Fall (average case):\n\nbest case: \\(\\mathcal{O} (n)\\)\nworst case: \\(\\mathcal{O} (n^2)\\)\naverage case: \\(\\mathcal{O} (n^2)\\)\n\nDer best case ergibt sich zum Beispiel, falls die Eingabeliste bereits sortiert ist, da der Algorithmus nur einmal durch die Liste gehen muss, entsprechend n-Mal. Folgende Abbildung verdeutlicht die Anzahl der durchgeführten Operationen im Falle einer vollständig zufälligen Liste und einer, bei welcher 95% der Werte bereits sortiert ist. Dabei wurden für jedes \\(\\mathsf n\\) jeweils 10000 Listen sortiert. Es ist der Mittelwert und die minimalen und maximalen Operationen dargestellt.\n\n\n10 42.0579\n20 181.0355\n30 419.407\n40 756.5538\n50 1194.3781\n60 1732.2329\n70 2368.4465\n80 3105.4017\n90 3941.7954\n100 4878.1801\n\n\n\n\n\nAbschätzung der Koplexität des Bubblesort-Algorithmus ohne Vorsortierung\n\n\n\n\n10 30.1403\n20 126.7865\n30 303.873\n40 543.9807\n50 907.6736\n60 1316.7905\n70 1860.8113\n80 2447.6622\n90 3206.3051\n100 3969.7775\n\n\n\n\n\nAbschätzung der Koplexität des Bubblesort-Algorithmus mit einer 95%-igen Vorsortierung",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>30</span>  <span class='chapter-title'>Eigenschaften</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/numerische_algorithmen.html",
    "href": "books/a-algorithmen/skript/numerische_algorithmen.html",
    "title": "31  Numerische Algorithmen",
    "section": "",
    "text": "31.1 Newton-Raphson-Verfahren\nEines der einfachsten und auch ältesten Verfahren zur Suche von Nullstellen von Funktionen ist das Newton-Raphson-Verfahren, welches bereits im 17-ten Jahrhundert entwickelt und eingestetzt wurde.",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Numerische Algorithmen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/numerische_algorithmen.html#newton-raphson-verfahren",
    "href": "books/a-algorithmen/skript/numerische_algorithmen.html#newton-raphson-verfahren",
    "title": "31  Numerische Algorithmen",
    "section": "",
    "text": "31.1.1 Anwendungen\nDas Finden von Nullstellen ist die Grundlage für viele Verfahren, welche z.B. für\n\ndas Lösen von nicht-linearen Gleichungen,\ndas Finden von Extremwerten, oder\nOptimierungsverfahren\n\neingesetzt werden kann.\n\n\n31.1.2 Grundidee\nDie Grundidee beruht auf einer iterativen Suche der Nullstelle \\(\\mathsf x_{ns}\\) einer stetig differenzierbaren Funktion \\(\\mathsf f(x)\\) mit Hilfe der ersten Ableitung \\(\\mathsf f'(x)\\). Durch das Anlegen von Tangenten an die aktuelle Näherung der Nullstelle \\(\\mathsf x_i\\) kann die nächste Näherung bestimmt werden.\nBei gegebenen Startwert, \\(\\mathsf x_0\\) für den ersten Iterationsschritt (\\(\\mathsf i=0\\)), können die folgenden Näherungen durch\n\\[\\mathsf x_{i+1} = x_i - \\frac{f(x_i)}{f'(x_i)} \\]\nberechnet werden. Dabei bestimmt die Wahl des Startwerts, welche der ggf. mehreren Nullstellen gefunden wird.\n\n\n31.1.3 Beispiel 1\nGegeben ist die Funktion \\(\\mathsf f(x) = x^2 - 1\\). Die Ableitung ist gegeben durch \\(\\mathsf f'(x) = 2x\\) und die Nullstellen lauten \\(\\mathsf x_{ns} = \\{-1, 1\\}\\).\nBei einem Startwert von \\(\\mathsf x_0 = 0.3\\) führt zu folgender Iteration:\n\n\nStartwert x_0 = 0.3000\n\nIterationsschritt i =  1, x_i = 0.3000\n   f(x_i)  = -0.9100\n   fp(x_i) = 0.6000\n   x_(i+1) = 1.8167\n\nIterationsschritt i =  2, x_i = 1.8167\n   f(x_i)  = 2.3003\n   fp(x_i) = 3.6333\n   x_(i+1) = 1.1836\n\nIterationsschritt i =  3, x_i = 1.1836\n   f(x_i)  = 0.4008\n   fp(x_i) = 2.3671\n   x_(i+1) = 1.0142\n\nIterationsschritt i =  4, x_i = 1.0142\n   f(x_i)  = 0.0287\n   fp(x_i) = 2.0285\n   x_(i+1) = 1.0001\n\n\nEndergebnis nach 5 Iterationen: x_(ns) = 1.0001\n\n\n\n\n&lt;Figure size 672x480 with 0 Axes&gt;\n\n\n\n\n\nNewton-Verfahren, Beispiel 1\n\n\n\nSchritt 0Schritt 1Schritt 2Schritt 3Schritt 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n31.1.4 Beispiel 2\nGegeben ist die Funktion \\(\\mathsf f(x) = \\sin(x) - 0.5\\) mit der Ableitung \\(\\mathsf f'(x) = \\cos(x)\\).\n\ndef f(x):\n    return np.sin(x) -0.5\ndef fp(x):\n    return np.cos(x)\n\nx0 = 1.3\n\nprint('Startwert x_0 = {:.4f}'.format(x0))\nprint()\n\nn = 5\nxi = [x0]\nfor i in range(1,n):\n    xp = xi[i-1]\n    xn = xp - (f(xp)/fp(xp))\n    \n    print('Iterationsschritt i = {:2d}, x_i = {:.4f}'.format(i, xp))\n    print('   f(x_i)  = {:.4f}'.format(f(xp)))\n    print('   fp(x_i) = {:.4f}'.format(fp(xp)))\n    print('   x_(i+1) = {:.4f}'.format(xn))\n    print()\n    \n    xi.append(xn)\n    \nprint()\nprint('Endergebnis nach {} Iterationen: x_(ns) = {:.4f}'.format(n, xi[-1]))\n\nStartwert x_0 = 1.3000\n\nIterationsschritt i =  1, x_i = 1.3000\n   f(x_i)  = 0.4636\n   fp(x_i) = 0.2675\n   x_(i+1) = -0.4329\n\nIterationsschritt i =  2, x_i = -0.4329\n   f(x_i)  = -0.9195\n   fp(x_i) = 0.9077\n   x_(i+1) = 0.5801\n\nIterationsschritt i =  3, x_i = 0.5801\n   f(x_i)  = 0.0481\n   fp(x_i) = 0.8364\n   x_(i+1) = 0.5226\n\nIterationsschritt i =  4, x_i = 0.5226\n   f(x_i)  = -0.0009\n   fp(x_i) = 0.8665\n   x_(i+1) = 0.5236\n\n\nEndergebnis nach 5 Iterationen: x_(ns) = 0.5236\n\n\n\n\n\nNewton-Verfahren, Beispiel 2\n\n\n\nSchritt 0Schritt 1Schritt 2Schritt 3Schritt 4",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Numerische Algorithmen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/numerische_algorithmen.html#euler-verfahren",
    "href": "books/a-algorithmen/skript/numerische_algorithmen.html#euler-verfahren",
    "title": "31  Numerische Algorithmen",
    "section": "31.2 Euler-Verfahren",
    "text": "31.2 Euler-Verfahren\nDas explizite Euler-Verfahren ist ein einfacher Algorithmus zur Bestimmung von Näherungslösungen von gewöhnlichen Differentialgleichungen, insbesondere Anfangswertprobleme. Das Verfahren wird hier anhand einer linearen Differentialgleichung 1. Ordnung demonstiert, hier ist \\(\\mathsf y = y(t)\\) eine Funktion der Zeit \\(\\mathsf t\\). Die Differentialgleichung lautet\n\\[\\dot y(t) + a(t)y(t) + b(t) = 0\\]\nMit einem vorgegebenen Anfangswert \\(\\mathsf y_0 = y(t_0)\\) kann die Näherungslösung iterativ bis zur gewünschten Endzeit \\(\\mathsf t_e\\) bestimmt werden. Dazu muss das betrachtete Zeitintervall \\(\\mathsf[t_0, t_e]\\) in \\(\\mathsf n_t\\) Teilintervalle aufgeteilt werden. Die Länge eines Teilintervalls ist\n\\[\\mathsf \\Delta t = \\frac{t_e - t_0}{n_t}\\quad .\\]\nDas iterative Verfahren beschreibt die Bestimmung der Lösung im nächsten Zeitinterval \\(\\mathsf t_{i+1}\\)\n\\[\\mathsf  y(t_{i+1}) = y(t_i) - \\Delta t \\big(a(t_i)y(t_i) + b(t_i)\\big)\\quad .\\]\n\n31.2.1 Beispiel 1\nMit \\(\\mathsf a(t) = 1\\), \\(\\mathsf b(t) = 0\\) und einem Anfangswert von \\(\\mathsf y_0 = 1\\).",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>31</span>  <span class='chapter-title'>Numerische Algorithmen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/zahlendarstellung.html",
    "href": "books/a-algorithmen/skript/zahlendarstellung.html",
    "title": "32  Exkurs: Interne Darstellung von Zahlen und Zeichen",
    "section": "",
    "text": "32.1 Analoge und digitale Signale\nDie Grundlage für alle modernen Computer ist die Digitalisierung. Diese ermöglicht es reale Informationen, Kommunikationsformen oder Anweisungen als eine Folge von zwei Zuständen 1/0 darzustellen. Computersysteme nutzen diese Reduktion bzw. Vereinfachung auf nur zwei Zustände zum Speichern, Übertragen und Verarbeiten von Daten.\nIn der Technik unterscheidet man grundsätzlich zwischen analogen und digitalen Signalen, wenn Informationen dargestellt, verarbeitet oder übertragen werden.",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exkurs: Interne Darstellung von Zahlen und Zeichen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/zahlendarstellung.html#analoge-und-digitale-signale",
    "href": "books/a-algorithmen/skript/zahlendarstellung.html#analoge-und-digitale-signale",
    "title": "32  Exkurs: Interne Darstellung von Zahlen und Zeichen",
    "section": "",
    "text": "32.1.1 Analoge Signale\nEin analoges Signal ist kontinuierlich in Zeit und Ausprägung. Es kann unendlich viele Werte innerhalb eines Bereichs annehmen – wie z. B. die Spannung eines Mikrofonsignals, die mit der Lautstärke variiert, oder die Temperatur, die sich stetig verändert.\nAnaloge Signale sind gut geeignet, um natürliche Phänomene direkt abzubilden, sind aber anfällig für Störungen und schwer exakt zu speichern oder weiterzuverarbeiten.\n\n\n32.1.2 Digitale Signale\nEin digitales Signal besteht aus diskreten Werten – meist zwei: 0 und 1. Es wird also in einzelnen Schritten dargestellt und ist damit für Computer besonders gut geeignet. Die kontinuierlichen Werte der realen Welt müssen dafür zunächst in digitale Werte umgewandelt werden (Analog-Digital-Wandlung).\nDigitale Signale lassen sich fehlerfrei speichern, übertragen und beliebig oft kopieren, ohne dass die Information an Qualität verliert.\n\n\n32.1.3 Vergleich: Analoge vs. digitale Signale\n\n\n\n\n\n\n\n\nMerkmal\nAnaloge Signale\nDigitale Signale\n\n\n\n\nSignalverlauf\nStetig, kontinuierlich\nDiskret, stufenweise\n\n\nWertebereich\nUnendlich viele Werte innerhalb eines Bereichs\nEndliche Anzahl (z. B. 0 und 1)\n\n\nStöranfälligkeit\nHoch – kleine Störungen wirken sich direkt aus\nGering – durch Fehlerkorrektur ausgleichbar\n\n\nSpeicherung\nSchwierig, da kontinuierlich\nEinfach und verlustfrei möglich\n\n\nVerarbeitung\nAufwendig, da kontinuierlich\nEffizient durch digitale Logik\n\n\nBeispiel\nPlattenspieler, Thermometer mit Zeiger\nMP3-Datei, Digitalkamera\n\n\n\n\n\n32.1.4 Umwandlung analoger zu digitaler Signale\nUm aus analogen Werten, z.B. aus einem Experiment, digitale Werte für die Auswertung z u gewinnen, werden Analog-Digital-Wandler (ADC) genutzt. Einfach gesagt, tastet ein ADC ein Signal mit einer vorgegebenen (endlichen) Abtastrate ab. Dabei wird der Signalwert einem der (endlich vielen) vorgegebenen Werteintervalle zugeordnet. Folgende Abbildung zeigt ein Beispiel für die Umwandlung eines analogen Signals (blaue Kurve) in ein digitales (orangene Punkte). Hier ist das Abtastintervall im Zeit- und Wertbereich jeweils Eins, in der Abbildung durch das graue Gitter veranschaulicht. Damit kann die vom ADC ermittelte Folge von Werten nur Punkte auf dem Gitter enthalten.\n\n\n\n\n\n\n\n\nFigure 32.1: Umwandlung eines digitalen (blau) zu einem analogen Signal (orange)",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exkurs: Interne Darstellung von Zahlen und Zeichen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/zahlendarstellung.html#digitale-zahlendarstellung",
    "href": "books/a-algorithmen/skript/zahlendarstellung.html#digitale-zahlendarstellung",
    "title": "32  Exkurs: Interne Darstellung von Zahlen und Zeichen",
    "section": "32.2 Digitale Zahlendarstellung",
    "text": "32.2 Digitale Zahlendarstellung\nIn den vorherigen Abschnitten haben wir gesehen, wie analoge Informationen in digitale Signale umgewandelt werden können. Damit ein Computer solche digitalen Informationen verarbeiten kann, müssen sie intern als Zahlen dargestellt werden - und zwar in einem für Computer verständlichen Format: dem Binärsystem.\nWir beschäftigen uns in diesem Abschnitt daher mit der Frage, wie Zahlen intern gespeichert und dargestellt werden. Dabei lernen wir unter anderem:\n\nWie Zahlen in verschiedenen Zahlensystemen dargestellt werden können (z. B. Binär, Dezimal, Hexadezimal),\nwie man zwischen diesen Systemen umrechnet,\nund wie man solche Umrechnungen auch algorithmisch beschreiben und in Code umsetzen kann.\n\n\n32.2.1 Dualsystem\nDa in der digitalen Elektronik nur mit zwei Zuständen gerechnet wird, bietet sich das Dualsystem, auch genannt Binärsystem, zur Zahlendarstellung an. Beispiele für Zahlendarstellungen zur Basis 2, wobei der Index die Basis angibt:\n\n510 = 1012\n10710 = 11010112\n263510 = 1010010010112\n\nDamit lassen sich Zahlen als eine Reihe bzw. Abfolge von 0/1-Zuständen darstellen.\n\n\n32.2.2 Hexadezimalsystem\nBei Zahlen zur Basis 16 müssen auch Stellen, welche größer als 9 sind, abgebildet werden. Hierzu werden Buchstaben eingesetzt, um die Ziffern ‘10’, dargestellt durch A, bis ‘15’ (F) abzubilden. Eine oft verwendete Schreibweise für Zahlen im Hexadezimalsystem ist das Vorstellen von 0x vor die Zahl, wie im folgenden Beispielen gezeigt:\n\n510 = 516 = 0x5\n10710 = 6B16 = 0x6B\n263510 = A4B16 = 0xA4B",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exkurs: Interne Darstellung von Zahlen und Zeichen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/zahlendarstellung.html#binäre-maßeinheiten",
    "href": "books/a-algorithmen/skript/zahlendarstellung.html#binäre-maßeinheiten",
    "title": "32  Exkurs: Interne Darstellung von Zahlen und Zeichen",
    "section": "32.3 Binäre Maßeinheiten",
    "text": "32.3 Binäre Maßeinheiten\nDa sich in der digitalen Welt alles um Potenzen von 2 dreht, haben sich aus technischen Gründen folgende Einheiten ergeben:\n\n1 Bit = eine Ziffer im Binärsystem, Wertebereich: 0 und 1\n1 Byte = acht Ziffern im Binärsystem, Wertebereich: 0 bis 255\n\nUm größere Datenmengen praktischer anzugeben, werden folgende Einheiten genutzt:\n\n1 KB = 1 kiloByte = 103 Byte\n1 MB = 1 megaByte = 106 Byte\n1 GB = 1 gigaByte = 109 Byte\n1 TB = 1 teraByte = 1012 Byte\n1 PB = 1 petaByte = 1015 Byte",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exkurs: Interne Darstellung von Zahlen und Zeichen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/zahlendarstellung.html#geschwindigkeit-der-datenübertragung",
    "href": "books/a-algorithmen/skript/zahlendarstellung.html#geschwindigkeit-der-datenübertragung",
    "title": "32  Exkurs: Interne Darstellung von Zahlen und Zeichen",
    "section": "32.4 Geschwindigkeit der Datenübertragung",
    "text": "32.4 Geschwindigkeit der Datenübertragung\nDie Geschwindigkeit mit der Daten übertragen werden können wird als Datenmenge pro Zeit angegeben. Hierbei wird die Zeit meist auf eine Sekunde bezogen. Beispielhaft sind hier einige Datenübertragungsraten beim Zugriff auf eine magnetische Festplatte (HDD) und auf ein Halbleiterlaufwerk (SSD) aufgeführt.\n\nLesen / Schreiben HDD: ~200 MB/s\nLesen / Schreiben SSD: ~500 MB/s\n\nAls weiteres Beispiel können maximale Übertragunsraten in verschiedenen Netzwerken genannt werden:\n\nüber das Mobilfunknetz, z.B. 3G: 384 kbit/s\nüber ein Netzwerkkabel, z.B. Fast Ethernet: ~100 Mbit/s",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exkurs: Interne Darstellung von Zahlen und Zeichen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/zahlendarstellung.html#darstellung-ganzer-zahlen",
    "href": "books/a-algorithmen/skript/zahlendarstellung.html#darstellung-ganzer-zahlen",
    "title": "32  Exkurs: Interne Darstellung von Zahlen und Zeichen",
    "section": "32.5 Darstellung ganzer Zahlen",
    "text": "32.5 Darstellung ganzer Zahlen\nDie Grundidee bei der digitalen Darstellung von Zahlen, hier ganze Zahlen, ist die Verwendung einer festen Anzahl von Bits. Diese bilden dann eine entsprechende Anazahl von Stellen im Dualsystem ab. Dieser Idee folgend, kann eine ganze Zahl mit Vorzeichen wie folgt als 8-Bit-Zahl dargestellt werden:\n\n\n\nBitzuordnung bei der Darstellung einer ganzen Zahl mit 8 Bit.\n\n\nFür zwei Zahlen aus dem obigen Beispiel für die Zahldarstellung im Dualsystem könnte die Bitzuweisung wie folgt aussehen.\n\n\n\nBeispiel der Bitzuordnung für die Zahl 5 mit 8 Bit.\n\n\n\n\n\nBeispiel der Bitzuordnung für die Zahl 107 mit 8 Bit.\n\n\nDurch die fixe Vorgabe der Stellen im Dualsystem, also hier der Bits, ergibt sich der Zahlenbereich, welcher mit diesen Bits abgebildet werden kann. Für die Darstellung von ganzen Zahlen mit 8 Bit, also mit einem Byte, ergibt sich somit\n\nkleinste Zahl: 02 = 0\ngrößte Zahl: 111111112 = 28-1 = 255 .\n\nNatürlich können auch länger Bitfolgen für einen größeren Zahlenbereich genutzt werden. Zusätzlich kann eines der Bits auch genutzt werden, um das Vorzeichen darzustellen. Folgende Abbildung zeigt die Darstellung einer vorzeichenbehafteten ganzen Zahl mit 32 Bit.\n\n\n\nBitzuordnung bei der Darstellung einer ganzen Zahl samt Vorzeichen mit 32 Bit.\n\n\nDer Wertebereich ist in diesem Fall gegeben durch:\n\nkleinste Zahl = -231 = -2,147,483,648\ngrößte Zahl = 231 - 1 = 2,147,483,647 .\n\nIn der Informatik wird solch eine Darstellung von ganzen Zahlen als Integer Datentyp bezeichnet. Im Englischen wird dieser als integer bezeichnet.",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exkurs: Interne Darstellung von Zahlen und Zeichen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/zahlendarstellung.html#umrechnung-zwischen-dezimal--und-binärzahlen",
    "href": "books/a-algorithmen/skript/zahlendarstellung.html#umrechnung-zwischen-dezimal--und-binärzahlen",
    "title": "32  Exkurs: Interne Darstellung von Zahlen und Zeichen",
    "section": "32.6 Umrechnung zwischen Dezimal- und Binärzahlen",
    "text": "32.6 Umrechnung zwischen Dezimal- und Binärzahlen\nUm zwischen Dezimalzahlen (zur Basis 10) und Binärzahlen (zur Basis 2) umzuwandeln, gibt es jeweils einfache Verfahren. Diese lassen sich auch leicht als Algorithmus in Programmiersprachen umsetzen.\n\n32.6.1 Von Binär nach Dezimal\nEine Binärzahl besteht aus einzelnen Stellen (Bits), die jeweils eine Potenz von 2 repräsentieren. Zur Umrechnung summiert man die Produkte der Ziffern mit ihrer jeweiligen Stellenwertigkeit:\n\\[\nz = \\sum_{i=0}^{n} b_i \\cdot 2^i\n\\]\nDabei ist: - \\(b_i \\in \\{0, 1\\}\\) das i-te Bit (von rechts gezählt), - \\(2^i\\) der Stellenwert der Position, - \\(z\\) die Dezimalzahl.\nBeispiel:\nUmwandlung von \\(1011_2\\) nach Dezimal:\n$$\n1011_2 &= 1 ^3 + 0 ^2 + 1 ^1 + 1 ^0 \\ &= 8 + 0 + 2 + 1 = 11_{10}\n$$\n\n\n32.6.2 Von Dezimal nach Binär\nZur Umwandlung einer Dezimalzahl in eine Binärzahl verwendet man die ganzzahlige Division durch 2. Der jeweilige Rest (0 oder 1) ergibt die Binärziffer. Man wiederholt diesen Vorgang so lange, bis der Quotient 0 ist, und liest die Reste von unten nach oben.\nBeispiel:\nUmwandlung von \\(11_{10}\\) nach Binär:\n\\[\n\\begin{array}{rcl}\n11 \\div 2 &= 5 &\\text{Rest } 1 \\\\\n5 \\div 2  &= 2 &\\text{Rest } 1 \\\\\n2 \\div 2  &= 1 &\\text{Rest } 0 \\\\\n1 \\div 2  &= 0 &\\text{Rest } 1 \\\\\n\\end{array}\n\\]\n→ Von unten gelesen ergibt das: \\(1011_2\\)\n\n\n\n\n\n\nMerke\n\n\n\nDie Umrechnung funktioniert immer, egal wie groß die Zahl ist – sie ist eine systematische Anwendung der Stellenwertsysteme. Computer arbeiten intern genau auf diese Weise, nur in Hardware.",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exkurs: Interne Darstellung von Zahlen und Zeichen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/zahlendarstellung.html#darstellung-reeller-zahlen",
    "href": "books/a-algorithmen/skript/zahlendarstellung.html#darstellung-reeller-zahlen",
    "title": "32  Exkurs: Interne Darstellung von Zahlen und Zeichen",
    "section": "32.7 Darstellung reeller Zahlen",
    "text": "32.7 Darstellung reeller Zahlen\nReelle Zahlen können nur angenährt als eine Gleitkommazahl digital dargestellt werden. Dazu wir die zur Verfügung stehende Menge an Bits auf folgende Zuordnungen aufgeteilt: Vorzeichen \\(\\mathsf s\\), Exponent \\(\\mathsf e\\) und Mantisse \\(\\mathsf m\\). Jedem dieser Bereiche wird eine feste Anzahl von Bits zugeordnet wodruch sich der Wertebereich und Genauigkeit der Darstellung ergibt. Im Allgemeinen kann somit eine Gleitkommazahl dargestellt werden als\n\\[ \\mathsf z = (-1)^s \\cdot m \\cdot 2^e .\\]\nEs existieren mehrere Ansätze für die Abbildung von Gleitkommazahlen. Insbesondere im IEEE754 Standard wird folgende Aufteilung definiert: Vorzeichen (1 bit), Exponent (11 bit) und Mantisse (52 bit):\n\n\n\nBitzuordnung bei der Darstellung einer reellen Zahl mit 64 bit.\n\n\nAus der obigen Festlegung der Bitzuweisung, ergeben sich die Größenordnung für den Wertebereich, welcher durch den Exponenten vorgegeben ist. Um auch Zahlen kleiner 1 darstellen zu können, kann der Exponent \\(\\mathsf e\\) auch negative Werte annehmen.\nFür den Exponenten \\(\\mathsf e\\) gilt\n\nkleinster Wert in Etwa: -(210 - 1) = -1023\ngrößter Wert in Etwa: ~ 210 - 1 = 1023 .\n\nOhne Beachtung der Mantisse und des Vorzeichens, ergibt sich mit den obigen Werten dieser Bereich für die Größenordnungen:\n\nkleinste Größenordnung: 2-1023 ~ 10-308\ngrößte Größenordnung: 21023 ~ 10308\n\nDie Genauigkeit, d.h. die kleinste darstellbare Differenz zwischen zwei Gleitkommazahlen, ergibt sich aus der Mantisse $ m$. Eine grobe Abschätzung der Genauigkeit kann wie folgt durchgeführt werden. Per Definition deckt die Mantisse einen Zahlenbereich von 0 bis etwa 10 ab. Dieser Bereich wird in obiger Festlegung mit 52 Bit dargestellt. Hieraus ergibt sich dann der kleinste Unterschied zu\n\nkleinster Unterschied zwischen zwei Gleitkommazahlen: 10 / 252 ~ 2·10-15\n\nBetrachtet man nun Dezimalzahlen, so entspricht das etwa der 15-ten Nachkommastelle.\nDer Datentyp, welcher für die Darstellung von Gleitkommazahlen verwendet wird, wird generell als float (engl. floating point number) bezeichnet. Im IEEE754 Standard werden viele verschiedene Darstellungen definiert.",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exkurs: Interne Darstellung von Zahlen und Zeichen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/zahlendarstellung.html#zeichendarstellung",
    "href": "books/a-algorithmen/skript/zahlendarstellung.html#zeichendarstellung",
    "title": "32  Exkurs: Interne Darstellung von Zahlen und Zeichen",
    "section": "32.8 Zeichendarstellung",
    "text": "32.8 Zeichendarstellung\nNeben Zahlen können auch Zeichen, z.B. für die Darstellung von Text, abgebildet werden. Die Grundidee ist dabei, dass die Zeichen als vorzeichenlose ganze Zahlen gespeichert und dann anhand einer Tabelle interpretiert werden. Ein Beispiel für eine solche Tabelle, welche den Zahlenwerte Zeichen zuordnet, ist die ASCII Tabelle. In dieser werden 7-Bit-Zahlen, d.h. 128 Zeichen, kodiert. In der 1963 erstellten –  und bis heute genutzten – Tabelle, sind sowohl nicht-druckbare Zeichen (z.B. Zeilenvorschub, Tabulatorzeichen) als auf folgende druckbare Zeichen enthalten:\n !\"#$%&'()*+,-./0123456789:;&lt;=&gt;?\n@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\n`abcdefghijklmnopqrstuvwxyz{|}~\nWobei das erste Zeichen das Leerzeichen ist.",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>32</span>  <span class='chapter-title'>Exkurs: Interne Darstellung von Zahlen und Zeichen</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/umrechnung_binaer.html",
    "href": "books/a-algorithmen/skript/umrechnung_binaer.html",
    "title": "33  Algorithmische Umrechnung von Zahlen: Dezimal ↔︎ Binär",
    "section": "",
    "text": "33.1 1. Umrechnung: Dezimal → Binär\nIn diesem Kapitel betrachten wir die Umrechnung zwischen Dezimal- und Binärzahlen algorithmisch. Dabei analysieren wir den Ablauf der Rechenschritte, beschreiben sie als Pseudocode, visualisieren sie mit Flussdiagrammen und setzen sie anschließend manuell in Python um.",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Algorithmische Umrechnung von Zahlen: Dezimal ↔ Binär</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/umrechnung_binaer.html#umrechnung-dezimal-binär",
    "href": "books/a-algorithmen/skript/umrechnung_binaer.html#umrechnung-dezimal-binär",
    "title": "33  Algorithmische Umrechnung von Zahlen: Dezimal ↔︎ Binär",
    "section": "",
    "text": "33.1.1 Grundidee\nWir wiederholen die ganzzahlige Division durch 2 und merken uns den Rest. Die Binärziffern ergeben sich aus den Resten — von unten nach oben gelesen.\n\n\n33.1.2 Flussdiagramm\n\n\n\nUmrechnug von Dezimal zu Binär\n\n\n\n\n33.1.3 Pseudocode\nEingabe: Dezimalzahl n\nInitialisiere leere Liste ziffern\nSolange n &gt; 0:\n    rest ← n mod 2\n    ziffern an rest anhängen\n    n ← n ganzzahlig geteilt durch 2\nAusgabe: ziffern in umgekehrter Reihenfolge\n\n\n33.1.4 Python-Implementierung\n\ndef dezimal_zu_binaer(n):\n    ziffern = []\n    while n &gt; 0:\n        ziffern.append(n % 2)\n        n //= 2\n    return ziffern[::-1]\n\ndezimal_zu_binaer(23)  # Beispiel: 23 → 10111\n\n[1, 0, 1, 1, 1]",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Algorithmische Umrechnung von Zahlen: Dezimal ↔ Binär</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/umrechnung_binaer.html#umrechnung-binär-dezimal",
    "href": "books/a-algorithmen/skript/umrechnung_binaer.html#umrechnung-binär-dezimal",
    "title": "33  Algorithmische Umrechnung von Zahlen: Dezimal ↔︎ Binär",
    "section": "33.2 2. Umrechnung: Binär → Dezimal",
    "text": "33.2 2. Umrechnung: Binär → Dezimal\n\n33.2.1 Grundidee\nJede Stelle repräsentiert eine Zweierpotenz. Wir addieren die Produkte der Ziffern mit ihrer Potenz.\n\n\n33.2.2 Flussdiagramm\n\n\n\nUmrechnug von Binär zu Dezimal\n\n\n\n\n33.2.3 Pseudocode\nEingabe: Liste binärer Ziffern (z. B. [1, 0, 1, 1])\nInitialisiere dezimalwert ← 0\nFür jede Stelle i von rechts nach links:\n    dezimalwert ← dezimalwert + ziffer * 2^position\nAusgabe: dezimalwert\n\n\n33.2.4 Python-Implementierung\n\ndef binaer_zu_dezimal(ziffern):\n    dezimalwert = 0\n    for i in range(len(ziffern)):\n        potenz = len(ziffern) - i - 1\n        dezimalwert += ziffern[i] * (2 ** potenz)\n    return dezimalwert\n\nbinaer_zu_dezimal([1, 0, 1, 1])  # Ergebnis: 11\n\n11",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Algorithmische Umrechnung von Zahlen: Dezimal ↔ Binär</span>"
    ]
  },
  {
    "objectID": "books/a-algorithmen/skript/umrechnung_binaer.html#mathematische-komplexität",
    "href": "books/a-algorithmen/skript/umrechnung_binaer.html#mathematische-komplexität",
    "title": "33  Algorithmische Umrechnung von Zahlen: Dezimal ↔︎ Binär",
    "section": "33.3 3. Mathematische Komplexität",
    "text": "33.3 3. Mathematische Komplexität\nBeide Algorithmen haben eine logarithmische Laufzeit bezogen auf die Eingabegröße \\(n\\), denn:\n\nDie Umrechnung Dezimal → Binär wiederholt die Division durch 2, bis \\(n = 0\\). Das sind \\(\\log_2(n)\\) Schritte.\nDie Umrechnung Binär → Dezimal summiert über \\(\\log_2(n)\\) Stellen.\n\nDaher gehören beide zur Klasse der logarithmischen Algorithmen.\n\n\n\n\n\n\nHinweis\n\n\n\nDiese Verfahren sind nicht nur theoretisch interessant – genau so arbeiten Computer intern mit Bitfolgen!",
    "crumbs": [
      "Algorithmen",
      "<span class='chapter-number'>33</span>  <span class='chapter-title'>Algorithmische Umrechnung von Zahlen: Dezimal ↔ Binär</span>"
    ]
  },
  {
    "objectID": "books/numerik/skript/einleitung.html",
    "href": "books/numerik/skript/einleitung.html",
    "title": "Numerik",
    "section": "",
    "text": "Die Numerik bzw. numerische Mathematik ist eine Disziplin der Mathematik in der Verfahren für Lösungen bzw. Näherungslösungen von Problemstellungen gesucht werden, welche nicht analytisch lösbar sind.\nDazu gehören die Teilgebiete der Integration und Differentiation als auch der Bereich der Differentialgleichungen. Viele Simulationsprogramme aus dem Ingenieurwesen verwenden numerische Verfahren zur Berechnung komplexer Sachverhalte. Insbesondere die Lösung von gewöhnlichen und partiellen Differentialgleichungen ist ohne die Numerik kaum möglich.\nZu den Anwendungsfelder gehören beispielsweise:\n\nVerformung von Körpern unter Kraftausübung\nSchwingungen von Gebäuden\nZeitliche Entwicklung von Stoffkonzentrationen\nStrömungsdynamik: Wasserbau, Umströmung von Gebäuden, Lüftungstechnik, Rauchausbreitung\nWärmetransport in Bauteilen",
    "crumbs": [
      "Numerik"
    ]
  },
  {
    "objectID": "books/numerik/skript/intro_integrale.html",
    "href": "books/numerik/skript/intro_integrale.html",
    "title": "34  Integration",
    "section": "",
    "text": "34.0.1 Ober- und Untersumme\nDie Bildung von Integralen findet beispielsweise bei der Bestimmung von Flächeninhalten oder von Gesamtkräften Anwendung. Formal wird das bestimmte Integral \\(\\mathsf{I}\\) der Funktion \\(\\mathsf{f(x)}\\) auf dem Intervall \\(\\mathsf{x \\in [a,b]}\\) wie folgt dargestellt.\n\\[ \\mathsf{I = \\int_a^b f(x)\\ dx} \\]\nIm Allgemeinen kann das Integral nicht analytisch gelöst werden, da die Stammfunktion \\(\\mathsf{F(x)}\\) nicht leicht zu bestimmen ist. In solchen Fällen können numersiche Verfahren eingesetzt werden um den Integralwert zu approximieren. Die numerische Integration wird oft auch als numersiche Quadratur bezeichnet.\nDieses Kapitel bietet eine kurze Übersicht von numerischen Integrationsmethoden:\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nEine der grundlegendsten Arten Integrale von Funktionen zu bestimmen sind die Ober- und Untersumme. Sie nähern den Integralwert durch eine Abschätzung nach oben bzw. unten an. Mit einer steigenden Anzahl von Stützstellen, d.h. Positionen an welchen die Funktion ausgewertet wird, konvergieren beide Abschätzungen gegen den Integralwert.",
    "crumbs": [
      "Numerik",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Integration</span>"
    ]
  },
  {
    "objectID": "books/numerik/skript/intro_integrale.html#definition",
    "href": "books/numerik/skript/intro_integrale.html#definition",
    "title": "34  Integration",
    "section": "34.1 Definition",
    "text": "34.1 Definition\nFür die Bildung der Ober- und Untersumme, werden gleichmäßig verteilte Stützstellen auf dem Intervall \\(\\mathsf{[a,b]}\\) benötigt. Werden \\(\\mathsf{n+1}\\) Stützstellen gewählt, so gilt:\n\\[ a = x_0 &lt; x_1 &lt; \\cdots &lt; x_n = b \\]\nDer Abstand der Stützstellen beträgt \\(\\mathsf{\\Delta x = (b-a)/(n-1)}\\). Auf jedem der \\(\\mathsf{n}\\) Teilintervalle \\(\\mathsf{[x_{i-1}, x_{i}]}\\) wird nun der maximale bzw. minimale Wert der Funktion \\(\\mathsf{f(x)}\\) bestimmt und als \\(\\mathsf{O_i}\\) bzw. \\(\\mathsf{U_i}\\) definiert.\n\\[ \\mathsf{O_i = \\max\\left( f(x) | x \\in [x_{i-1}, x_{i}] \\right)} \\] \\[ \\mathsf{U_i = \\min\\left( f(x) | x \\in [x_{i-1}, x_{i}] \\right)} \\]\nDie gesuchte Approximation des Integrals ist die Summe der \\(\\mathsf{O_i}\\) bzw. \\(\\mathsf{U_i}\\) mal der Breite des Teilintervalls, hier \\(\\mathsf{\\Delta x}\\):\n\\[ \\sum_{i=1}^n \\Delta x U_i \\lesssim I \\lesssim \\sum_{i=1}^n \\Delta x O_i \\]",
    "crumbs": [
      "Numerik",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Integration</span>"
    ]
  },
  {
    "objectID": "books/numerik/skript/intro_integrale.html#beispiel",
    "href": "books/numerik/skript/intro_integrale.html#beispiel",
    "title": "34  Integration",
    "section": "34.2 Beispiel",
    "text": "34.2 Beispiel\nBeispielhaft soll folgendes Integral bestimmt werden\n\\[ \\mathsf{I = \\int_0^2\\sin(3x) + 2x \\ dx} \\]\n\ndef fkt(x):\n    return np.sin(3*x) + 2*x\n\n# Daten für die Visualisierung\nx = np.linspace(0, 2, 100)\ny = fkt(x)\n\n# Exakte Lösung\nI_exakt = (-1/3*np.cos(3*2) + 2**2) - (-1/3)\n\nAls erstes werden die Stützstellen gleichmäßig im Intervall \\(\\mathsf{[0,2]}\\) verteilt.\n\nn = 5\n\nxi = np.linspace(0, 2, n)\nyi = fkt(xi)\n\nDie beiden Summen benötigen die Extremwerte der zu integrierenden Funktion in den Teilintervallen. Diese werden mit Hilfe einer Funktionsauswertung auf dem Teilintervall bestimmt. Für die nachfolgende Visualisierung hat die Menge der Summen ebenfalls \\(\\mathsf{n}\\) Elemente.\n\noben = np.zeros(n)\nunten = np.zeros(n)\n\nfor i in range(len(oben)-1): \n    cx = np.linspace(xi[i], xi[i+1], 50)\n    cy = fkt(cx)\n    oben[i+1] = np.max(cy)\n    unten[i+1] = np.min(cy)\n\nDie ersten Elemente der beiden Summenlisten werden auf die ersten Funktionswerte gesetzt, dies dient nur der folgenden Darstellung.\n\noben[0] = yi[0]\nunten[0] = yi[0]\n\nVisualisierung der einzelnen Funktionen.\n\nplt.plot(x, y, label='Funktion')\nplt.scatter(xi, yi, label='Stützstellen', c='C3', zorder=3)\nplt.plot(xi, oben, drawstyle='steps-pre', label='Obersumme')\nplt.plot(xi, unten, drawstyle='steps-pre', label='Untersumme')\n\nplt.vlines(xi, ymin=unten, ymax=oben, color='C1', alpha=0.6)\nplt.vlines(xi, ymin=0, ymax=unten, color='C2', alpha=0.6)\n\nplt.xlabel('x')\nplt.ylabel('y')\n\nplt.grid()\nplt.legend();\n\n\n\n\n\n\n\n\nDas obige Verfahren kann nun in einer Funktion zusammengefasst werden, welche die Summen der beiden Folgen zurückgibt.\n\ndef ou_summe(n, a=0, b=2):\n    xi = np.linspace(a, b, n)\n    yi = fkt(xi)\n    dx = xi[1] - xi[0]\n    \n    sum_oben = 0\n    sum_unten = 0\n    \n    for i in range(n-1): \n        cx = np.linspace(xi[i], xi[i+1], 50)\n        cy = fkt(cx)\n        oben = np.max(cy)\n        unten = np.min(cy)\n        sum_oben += dx * oben\n        sum_unten += dx * unten\n    \n    return sum_oben, sum_unten\n\nFür eine systematische Untersuchung des Konvergenzverhaltens, wird die Integrationsfunktion für verschiedene Anzahlen von Stützstellen aufgerufen.\n\nn_max = 100\nns = np.arange(2, n_max, 1, dtype=int)\nos = np.zeros(len(ns))\nus = np.zeros(len(ns))\n\n\nfor i, n in enumerate(ns):\n    o, u = ou_summe(n)\n    os[i] = o\n    us[i] = u\n\nDie graphische Darstellung der beiden Summen zeigt eine kontinuierliche Annäherung dieser.\n\nplt.plot(ns, os, label='Obersumme')\nplt.plot(ns, us, label='Untersumme')\n\nplt.axhline(y=I_exakt, color='C3', alpha=0.3)\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Integralwert')\n\nplt.grid()\nplt.legend();\n\n\n\n\n\n\n\n\nDies wird insbesondere deutlich, wenn die Differenz der beiden Summen aufgetragen wird. Mit einer logarithmischen Darstellung kann die kontinuierliche Annäherung auch quantitativ abgelesen werden.\n\nplt.plot(ns, os-us)\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz Ober- und Untersumme')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.grid();",
    "crumbs": [
      "Numerik",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Integration</span>"
    ]
  },
  {
    "objectID": "books/numerik/skript/intro_integrale.html#interpolation",
    "href": "books/numerik/skript/intro_integrale.html#interpolation",
    "title": "34  Integration",
    "section": "34.3 Interpolation",
    "text": "34.3 Interpolation\nBei der Bildung der Ober- und Untersumme wurde die zu integrierende Funktion durch einen konstanten Wert in den Teilintervallen zwischen den Stützstellen angenähert. Eine genauere Berechnung des Integrals kann durch eine bessere Interpolation erfolgen. Dazu eignen sich Polynome, da diese leicht zu Integrieren sind.\n\n34.3.1 Trapezregel\nDie Trapezregel beruht auf der Annäherung der zu integrierenden Funktion durch Geraden, d.h. Polynome vom Grad 1, auf den Teilintervallen. Die Approximation des Integralwertes ergibt sich entsprechend aus den Flächeninhalten der so entstandenen Trapeze.\nWie im vorhergehenden Kapitel wird das Verfahren anhand folgender Funktion demonstriert\n\\[ \\mathsf{I = \\int_0^2\\sin(3x) + 2x \\ dx} \\]\n\ndef fkt(x):\n    return np.sin(3*x) + 2*x\n\n# Daten für die Visualisierung\nx = np.linspace(0, 2, 100)\ny = fkt(x)\n\n# Exakte Lösung\nI_exakt = (-1/3*np.cos(3*2) + 2**2) - (-1/3)\n\nBildung der Stützpunkte:\n\nn = 5\n\nxi = np.linspace(0, 2, n)\nyi = fkt(xi)\n\nZunächst erfolgt noch die Visualisierung des Verfahrens.\n\nplt.plot(x, y, label='Funktion')\nplt.scatter(xi, yi, label='Stützstellen', c='C3')\nplt.plot(xi, yi, label='Approximation', c='C1')\n\nplt.vlines(xi, ymin=0, ymax=yi, color='C1', alpha=0.3)\n\nplt.grid()\nplt.legend();\n\n\n\n\n\n\n\n\nDie Integration selbst kann mittels der Funktion scipy.integrate.trapezoid ausgeführt werden.\n\nres = scipy.integrate.trapezoid(yi, xi)\nprint(f\"Integralwert mit {n} Stützstellen: {res:.4f}\")\n\nIntegralwert mit 5 Stützstellen: 4.0107\n\n\nDer so ermittelte Wert nähert sich dem exakten Wert mit zunehmender Anzahl der Stützstellen.\n\nn_max = 50\nns = np.arange(2, n_max, 1, dtype=int)\ntr = np.zeros(len(ns))\n\nfor i, n in enumerate(ns):\n    xi = np.linspace(0, 2, n)\n    yi = fkt(xi)\n    tr[i] = scipy.integrate.trapezoid(yi, xi)\n\n\nplt.plot(ns, tr)\nplt.axhline(y=I_exakt, color='C3', alpha=0.3)\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Integralwert')\n\nplt.grid();\n\n\n\n\n\n\n\n\n\nplt.plot(ns, np.abs(tr-I_exakt))\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz zum exakten Wert')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.grid();\n\n\n\n\n\n\n\n\n\n\n34.3.2 Simpsonregel\nDie Verwendung eines Polynoms vom zweiten Grad führt zur Simpsonregel. Hierzu wird die Funktion an einem Zwischenwert, mittig im Teilintervall, ausgewertet und zusammen mit den Werten an den Stützstellen zur Bestimmung der Polynomkoeffizienten verwendet.\nAnhand des obigen Beispiels wird die Simpsonregel visuell demonstriert.\n\nn = 5\n\nxi = np.linspace(0, 2, n)\nyi = fkt(xi)\n\n\nplt.plot(x, y, label='Funktion')\nplt.scatter(xi, yi, label='Stützstellen', c='C3')\n\n# Bestimmung und Plotten der Polynome\nfor i in range(n-1):\n    dx = xi[i+1] - xi[i]\n    cx = (xi[i] + xi[i+1]) / 2\n    cy = fkt(cx)\n\n    P = np.polyfit([xi[i], cx, xi[i+1]], [yi[i], cy, yi[i+1]], 2)\n    \n    Px = np.linspace(xi[i], xi[i+1], 20)\n    Py = np.polyval(P, Px)\n    \n    label=None\n    if i==0: \n        label='Approximation'\n    \n    plt.plot(Px, Py, color='C1', label=label)\n\nplt.vlines(xi, ymin=0, ymax=yi, color='C1', alpha=0.3)\n\nplt.grid()\nplt.legend();\n\n\n\n\n\n\n\n\nDie Simpsonregel ist bereits in der Funktion scipy.integrate.simpson implementiert. Im Folgenden wird nur die Differenz zur Trapezregel demonstriert.\n\nn_max = 50\nns = np.arange(3, n_max, 2, dtype=int)\nsi = np.zeros(len(ns))\ntr = np.zeros(len(ns))\n\nfor i, n in enumerate(ns):\n    xi = np.linspace(0, 2, n)\n    yi = fkt(xi)\n    si[i] = scipy.integrate.simpson(yi, xi)\n    tr[i] = scipy.integrate.trapezoid(yi, xi)\n\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0. 1. 2.] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.  0.5 1.  1.5 2. ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.33333333 0.66666667 1.         1.33333333 1.66666667\n 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.   0.25 0.5  0.75 1.   1.25 1.5  1.75 2.  ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.  0.2 0.4 0.6 0.8 1.  1.2 1.4 1.6 1.8 2. ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.16666667 0.33333333 0.5        0.66666667 0.83333333\n 1.         1.16666667 1.33333333 1.5        1.66666667 1.83333333\n 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.14285714 0.28571429 0.42857143 0.57142857 0.71428571\n 0.85714286 1.         1.14285714 1.28571429 1.42857143 1.57142857\n 1.71428571 1.85714286 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.    0.125 0.25  0.375 0.5   0.625 0.75  0.875 1.    1.125 1.25  1.375\n 1.5   1.625 1.75  1.875 2.   ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.11111111 0.22222222 0.33333333 0.44444444 0.55555556\n 0.66666667 0.77777778 0.88888889 1.         1.11111111 1.22222222\n 1.33333333 1.44444444 1.55555556 1.66666667 1.77777778 1.88888889\n 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.  1.1 1.2 1.3 1.4 1.5 1.6 1.7\n 1.8 1.9 2. ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.09090909 0.18181818 0.27272727 0.36363636 0.45454545\n 0.54545455 0.63636364 0.72727273 0.81818182 0.90909091 1.\n 1.09090909 1.18181818 1.27272727 1.36363636 1.45454545 1.54545455\n 1.63636364 1.72727273 1.81818182 1.90909091 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.08333333 0.16666667 0.25       0.33333333 0.41666667\n 0.5        0.58333333 0.66666667 0.75       0.83333333 0.91666667\n 1.         1.08333333 1.16666667 1.25       1.33333333 1.41666667\n 1.5        1.58333333 1.66666667 1.75       1.83333333 1.91666667\n 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.07692308 0.15384615 0.23076923 0.30769231 0.38461538\n 0.46153846 0.53846154 0.61538462 0.69230769 0.76923077 0.84615385\n 0.92307692 1.         1.07692308 1.15384615 1.23076923 1.30769231\n 1.38461538 1.46153846 1.53846154 1.61538462 1.69230769 1.76923077\n 1.84615385 1.92307692 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.07142857 0.14285714 0.21428571 0.28571429 0.35714286\n 0.42857143 0.5        0.57142857 0.64285714 0.71428571 0.78571429\n 0.85714286 0.92857143 1.         1.07142857 1.14285714 1.21428571\n 1.28571429 1.35714286 1.42857143 1.5        1.57142857 1.64285714\n 1.71428571 1.78571429 1.85714286 1.92857143 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.06666667 0.13333333 0.2        0.26666667 0.33333333\n 0.4        0.46666667 0.53333333 0.6        0.66666667 0.73333333\n 0.8        0.86666667 0.93333333 1.         1.06666667 1.13333333\n 1.2        1.26666667 1.33333333 1.4        1.46666667 1.53333333\n 1.6        1.66666667 1.73333333 1.8        1.86666667 1.93333333\n 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.     0.0625 0.125  0.1875 0.25   0.3125 0.375  0.4375 0.5    0.5625\n 0.625  0.6875 0.75   0.8125 0.875  0.9375 1.     1.0625 1.125  1.1875\n 1.25   1.3125 1.375  1.4375 1.5    1.5625 1.625  1.6875 1.75   1.8125\n 1.875  1.9375 2.    ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.05882353 0.11764706 0.17647059 0.23529412 0.29411765\n 0.35294118 0.41176471 0.47058824 0.52941176 0.58823529 0.64705882\n 0.70588235 0.76470588 0.82352941 0.88235294 0.94117647 1.\n 1.05882353 1.11764706 1.17647059 1.23529412 1.29411765 1.35294118\n 1.41176471 1.47058824 1.52941176 1.58823529 1.64705882 1.70588235\n 1.76470588 1.82352941 1.88235294 1.94117647 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.05555556 0.11111111 0.16666667 0.22222222 0.27777778\n 0.33333333 0.38888889 0.44444444 0.5        0.55555556 0.61111111\n 0.66666667 0.72222222 0.77777778 0.83333333 0.88888889 0.94444444\n 1.         1.05555556 1.11111111 1.16666667 1.22222222 1.27777778\n 1.33333333 1.38888889 1.44444444 1.5        1.55555556 1.61111111\n 1.66666667 1.72222222 1.77777778 1.83333333 1.88888889 1.94444444\n 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.05263158 0.10526316 0.15789474 0.21052632 0.26315789\n 0.31578947 0.36842105 0.42105263 0.47368421 0.52631579 0.57894737\n 0.63157895 0.68421053 0.73684211 0.78947368 0.84210526 0.89473684\n 0.94736842 1.         1.05263158 1.10526316 1.15789474 1.21052632\n 1.26315789 1.31578947 1.36842105 1.42105263 1.47368421 1.52631579\n 1.57894737 1.63157895 1.68421053 1.73684211 1.78947368 1.84210526\n 1.89473684 1.94736842 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.   0.05 0.1  0.15 0.2  0.25 0.3  0.35 0.4  0.45 0.5  0.55 0.6  0.65\n 0.7  0.75 0.8  0.85 0.9  0.95 1.   1.05 1.1  1.15 1.2  1.25 1.3  1.35\n 1.4  1.45 1.5  1.55 1.6  1.65 1.7  1.75 1.8  1.85 1.9  1.95 2.  ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.04761905 0.0952381  0.14285714 0.19047619 0.23809524\n 0.28571429 0.33333333 0.38095238 0.42857143 0.47619048 0.52380952\n 0.57142857 0.61904762 0.66666667 0.71428571 0.76190476 0.80952381\n 0.85714286 0.9047619  0.95238095 1.         1.04761905 1.0952381\n 1.14285714 1.19047619 1.23809524 1.28571429 1.33333333 1.38095238\n 1.42857143 1.47619048 1.52380952 1.57142857 1.61904762 1.66666667\n 1.71428571 1.76190476 1.80952381 1.85714286 1.9047619  1.95238095\n 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.04545455 0.09090909 0.13636364 0.18181818 0.22727273\n 0.27272727 0.31818182 0.36363636 0.40909091 0.45454545 0.5\n 0.54545455 0.59090909 0.63636364 0.68181818 0.72727273 0.77272727\n 0.81818182 0.86363636 0.90909091 0.95454545 1.         1.04545455\n 1.09090909 1.13636364 1.18181818 1.22727273 1.27272727 1.31818182\n 1.36363636 1.40909091 1.45454545 1.5        1.54545455 1.59090909\n 1.63636364 1.68181818 1.72727273 1.77272727 1.81818182 1.86363636\n 1.90909091 1.95454545 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.04347826 0.08695652 0.13043478 0.17391304 0.2173913\n 0.26086957 0.30434783 0.34782609 0.39130435 0.43478261 0.47826087\n 0.52173913 0.56521739 0.60869565 0.65217391 0.69565217 0.73913043\n 0.7826087  0.82608696 0.86956522 0.91304348 0.95652174 1.\n 1.04347826 1.08695652 1.13043478 1.17391304 1.2173913  1.26086957\n 1.30434783 1.34782609 1.39130435 1.43478261 1.47826087 1.52173913\n 1.56521739 1.60869565 1.65217391 1.69565217 1.73913043 1.7826087\n 1.82608696 1.86956522 1.91304348 1.95652174 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_39894/1922737122.py:9: DeprecationWarning: You are passing x=[0.         0.04166667 0.08333333 0.125      0.16666667 0.20833333\n 0.25       0.29166667 0.33333333 0.375      0.41666667 0.45833333\n 0.5        0.54166667 0.58333333 0.625      0.66666667 0.70833333\n 0.75       0.79166667 0.83333333 0.875      0.91666667 0.95833333\n 1.         1.04166667 1.08333333 1.125      1.16666667 1.20833333\n 1.25       1.29166667 1.33333333 1.375      1.41666667 1.45833333\n 1.5        1.54166667 1.58333333 1.625      1.66666667 1.70833333\n 1.75       1.79166667 1.83333333 1.875      1.91666667 1.95833333\n 2.        ] as a positional argument. Please change your invocation to use keyword arguments. From SciPy 1.14, passing these as positional arguments will result in an error.\n  si[i] = scipy.integrate.simpson(yi, xi)\n\n\n\nplt.plot(ns, np.abs(tr-I_exakt), label='Trapezregel')\nplt.plot(ns, np.abs(si-I_exakt), label='Simpsonregel')\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz zum exakten Wert')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.legend()\nplt.grid();",
    "crumbs": [
      "Numerik",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Integration</span>"
    ]
  },
  {
    "objectID": "books/numerik/skript/intro_integrale.html#monte-carlo",
    "href": "books/numerik/skript/intro_integrale.html#monte-carlo",
    "title": "34  Integration",
    "section": "34.4 Monte-Carlo",
    "text": "34.4 Monte-Carlo\nEin ganz anderer Ansatz zur Integration wird mit dem Monte-Carlo-Ansatz verfolgt. Hierbei werden Zufallspunkte \\(\\mathsf{x_i}\\) innerhalb der gesuchten Integralbereichs generiert. Der Mittelwert der dazugehörigen Summe der Funktionswerte \\(\\mathsf{f(x_i)}\\) nähert das Integral an. Insbesondere für eine kleine Anzahl von Zufallswerten kann das Ergebnis deutlich vom exakten Wert abweichen. Der Vorteil des Verfahrens wird bei hochdimensionalen Integralen deutlich.\nFür \\(\\mathsf{n \\gg 1}\\) zufällige Stützstellen \\(\\mathsf{x_i \\in [a, b]}\\) gilt folgende Näherung\n\\[\\mathsf{I = \\int_a^b f(x)\\ dx \\approx \\frac{b-a}{n}\\sum_{i=1}^n f(x_i)} \\]\nFür das Beispiel aus den vorhergehenden Kapiteln gilt\n\ndef fkt(x):\n    return np.sin(3*x) + 2*x\n\n# Daten für die Visualisierung\nx = np.linspace(0, 2, 100)\ny = fkt(x)\n\n# Exakte Lösung\nI_exakt = (-1/3*np.cos(3*2) + 2**2) - (-1/3)\n\n\nn = 2000\nxi = np.random.random(n) * 2\nyi = fkt(xi)\nI = 2 * 1/n * np.sum(yi)\nprint(f\"Integralwert für {n} Stützstellen: {I:.4f}\")\n\nIntegralwert für 2000 Stützstellen: 4.0532\n\n\n\nn_max = 50000\ndn = 250\nns = np.arange(dn, n_max, dn, dtype=int)\nmc = np.zeros(len(ns))\n\nxi = np.zeros(n_max)\n\nfor i, n in enumerate(ns):\n    xi[n-dn:n] = np.random.random(dn) * 2\n    yi = fkt(xi[:n])\n    mc[i] = 2 * 1/n * np.sum(yi)\n\n\nplt.plot(ns, np.abs(mc-I_exakt))\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz zum exakten Wert')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.grid();\n\n\n\n\n\n\n\n\nAlternativ kann auch das Flächenverhältnis zwischen der zu integrierenden Funktion und einer Referenzfläche \\(\\mathsf{A_r}\\) gebildet werden. Hierzu werden \\(\\mathsf{n}\\) Zufallszahlenpaare \\(\\mathsf{(x_i, y_i)}\\) generiert und gezählt wieviele davon in der gesuchten Fläche liegen. Die Annahme ist, dass sich beide Verhältnisse für große \\(\\mathsf{n}\\) annähern. Im einfachsten Fall, wenn \\(\\mathsf{f(x) \\ge 0}\\), gilt folgende Abschätzung\n\\[\\mathsf {I \\approx \\frac{A_r \\cdot \\left|\\left\\{y_i \\ |\\  y_i &lt; f(x_i)\\right\\}\\right|}{n}} \\]\nIm obigen Beispiel kann die Fläche \\(\\mathsf{[0, 2] \\times [0, 4] = 8}\\) als Referenzfläche verwendet werden.\n\nn = 2000\nxi = np.random.random(n) * 2\nyi = np.random.random(n) * 4\n\nz = np.sum(yi &lt; fkt(xi))\n\nI = z / n * 8\nprint(f\"Integralwert für {n} Stützstellen: {I}\")\n\nIntegralwert für 2000 Stützstellen: 3.948\n\n\n\nn_max = 50000\ndn = 250\nns = np.arange(dn, n_max, dn, dtype=int)\nmc = np.zeros(len(ns))\n\nxi = np.zeros(n_max)\nyi = np.zeros(n_max)\n\nfor i, n in enumerate(ns):\n    xi[n-dn:n] = np.random.random(dn) * 2\n    yi[n-dn:n] = np.random.random(dn) * 4\n    z = np.sum(yi[:n] &lt; fkt(xi[:n]))\n    mc[i] = z / n * 8\n\n\nplt.plot(ns, np.abs(mc-I_exakt))\n\nplt.xlabel('Anzahl der Stützstellen n')\nplt.ylabel('Differenz zum exakten Wert')\n\n# plt.xscale('log')\nplt.yscale('log')\n\nplt.grid();",
    "crumbs": [
      "Numerik",
      "<span class='chapter-number'>34</span>  <span class='chapter-title'>Integration</span>"
    ]
  },
  {
    "objectID": "books/numerik/skript/intro_ableitungen.html",
    "href": "books/numerik/skript/intro_ableitungen.html",
    "title": "35  Differentiation",
    "section": "",
    "text": "35.1 Taylor-Entwicklung\nDie numerische Bestimmung von Ableitungen wird hier anhand von zwei Ansätzen demonstriert. Zum Einen als Differenzenquotienten und zum Anderen über das Polynomfitting. Angewendet werden diese Verfahren z.B. beim Suchen von Extrema in Experimental- oder Simulationsdaten, beim Lösen von Differentialgleichungen oder bei Optimierungsverfahren.\nObwohl die analytische Bildung einer Ableitung oft viel einfacher ist als die Integration, ist dies in den oben genannten Fällen nicht direkt möglich. Gesucht ist hierbei immer die Ableitung \\(\\mathsf{f'(x)}\\) einer Funktion \\(\\mathsf{f(x)}\\) oder einer diskreten Punktmenge \\(\\mathsf{(x_i, y_i)}\\) an einer bestimmten Stelle \\(\\mathsf{x=x_0}\\) oder auf einem Intervall.\nDie Grundidee bei den hier vorgestellten Differenzenquotienten bzw. Differenzenformeln ist die Annäherung der abzuleitenden Funktion mit einer Taylor-Entwicklung an mehreren Stellen. Damit kann nach der gesuchte Ableitung an der entsprechenden Entwicklungsstelle aufgelöst werden.\nMittels der Taylor-Entwicklung kann jede beliebig oft stetig differenzierbare Funktion \\(\\mathsf{f(x)}\\) um einem Entwicklungspunkt \\(\\mathsf{x_0}\\) beliebig genau angenähert werden. Die funktionale Abhängigkeit bezieht sich nun auf die Variable \\(\\mathsf{h}\\), welche nur in direkter Umgebung um \\(\\mathsf{x_0}\\) betrachtet wird. Die Taylor-Entwicklung lautet:\n\\[ \\mathsf{f(x_0 + h) = \\sum_{i=0}^{\\infty}\\frac{1}{i!}f^{(i)}(x_0)\\cdot h^i} \\] \\[ \\mathsf{ = f(x_0) + f'(x_0)\\cdot h + \\frac{1}{2} f''(x_0)\\cdot h^2 + \\frac{1}{6}f'''(x_0)\\cdot h^3 + \\cdots} \\]\nDiese Entwicklung kann auch nur bis zu einer vorgegebenen Ordnung betrachtet werden. So nimmt die Entwicklung bis zur Ordnung \\(\\mathsf{ \\mathcal{O}(h^3)}\\) folgende Form an:\n\\[\\mathsf{ f(x_0 + h) = f(x_0) + f'(x_0)\\cdot h + \\frac{1}{2} f''(x_0)\\cdot h^2 + \\mathcal{O}(h^3)} \\]\nHierbei deutet das Landau-Symbol \\(\\mathsf{\\mathcal{O}}\\) die Ordnung an, welche die vernachlässigten Terme, hier ab \\(\\mathsf{h^3}\\), als Approximationsfehler zusammenfasst. Die Ordnung gibt an wie schnell bzw. mit welchem funktionalem Zusammenhang der Approximationsfehler gegen Null läuft für \\(\\mathsf{h \\rightarrow 0}\\).\nEine graphische Darstellung der ersten Elemente der Reihe verdeutlichen nochmals die Grundidee. Das folgende Beispiel entwickelt die Funktion\n\\[ \\mathsf{f(x) = \\sin(3x) + 2x} \\]\nam Punkt \\(\\mathsf{x_0=0.85}\\).\ndef fkt(x, p=0):\n    if p==0:\n        return np.sin(3*x) + 2*x\n    if p==1:\n        return 3*np.cos(3*x) + 2\n    if p==2:\n        return -9*np.sin(3*x)\n    if p==3:\n        return -27*np.cos(3*x)\n    return None\n\n# Daten für die Visualisierung\nx = np.linspace(0, 2, 100)\ny = fkt(x, p=0)\nx0 = 0.85\n\n# Taylor-Elemente\nte = []\nte.append(0*(x-x0) + fkt(x0, p=0))\nte.append((x-x0) * fkt(x0, p=1))\nte.append((x-x0)**2 * fkt(x0, p=2) * 1/2)\nte.append((x-x0)**3 * fkt(x0, p=3) * 1/6)\nplt.plot(x, y, color='Grey', lw=3, label=\"Funktion\")\nplt.plot(x, te[0], label=\"$\\mathsf{\\mathcal{O}(1)}$\")\nplt.plot(x, te[0] + te[1], label=\"$\\mathsf{\\mathcal{O}(h)}$\")\nplt.plot(x, te[0] + te[1] + te[2], label=\"$\\mathsf{\\mathcal{O}(h^2)}$\")\nplt.plot(x, te[0] + te[1] + te[2] + te[3], label=\"$\\mathsf{\\mathcal{O}(h^3)}$\")\n\nplt.vlines(x0, ymin=0, ymax=fkt(x0), color='Grey', ls='--', alpha=0.5)\n\nplt.ylim([0,4])\n\nplt.legend(bbox_to_anchor=(1.05, 1.0), loc='upper left')\nplt.grid()\nplt.xlabel('x')\nplt.ylabel('y');",
    "crumbs": [
      "Numerik",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Differentiation</span>"
    ]
  },
  {
    "objectID": "books/numerik/skript/intro_ableitungen.html#differenzenformeln",
    "href": "books/numerik/skript/intro_ableitungen.html#differenzenformeln",
    "title": "35  Differentiation",
    "section": "35.2 Differenzenformeln",
    "text": "35.2 Differenzenformeln\nIn diesem Abschnitt werden Berechnungsformeln für die Approximation von Ableitungen durch Bildung von Funktionswertdifferenzen vorgestellt. Diese beruhen alle auf der Taylor-Entwicklung und können für beliebige Ableitungen und Ordnungen formuliert werden. Die einfachsten davon werden hier vorgestellt.\n\n35.2.1 Erste Ableitung erster Ordnung\nDie einfachste Differenzenformel ergibt sich aus der Taylor-Reihe bis \\(\\mathsf{\\mathcal{O}(h^2)}\\). Hier kann die Reihe direkt nach der gesuchten Ableitung an der Stelle \\(\\mathsf{x_0}\\) umgeformt werden.\n\\[\\mathsf{f(x_0 + h) = f(x_0) + f'(x_0)h + \\mathcal{O}(h^2)} \\] \\[\\mathsf{\\Rightarrow \\quad f'(x_0) = \\frac{f(x_0 + h) - f(x_0)}{h} + \\mathcal{O}(h)} \\]\nDies ist die vorwärtsgerichtete Differenzformel erster Ordnung für die erste Ableitung. Erste Ordnung bedeutet hierbei, dass im Grenzwert \\(\\mathsf{h\\rightarrow 0}\\) der Approximationsfehler linear mit der Schrittweite abnimmt.\nNach dieser Formel muss die abzuleitende Funktion an zwei Stellen \\(\\mathsf{f(x_0)}\\) und \\(\\mathsf{f(x_0+h)}\\) ausgewertet werden, um die Ableitung numerisch zu bestimmen. Im Grenzwert für eine beliebig kleine Schrittweite, d.h. \\(\\mathsf{h \\rightarrow 0}\\), nähert sich dieser Quotient der exakten Ableitung an der Stelle \\(\\mathsf{x_0}\\) an.\nDas folgende Beispiel demonstriert die Näherung anhand der Funktion\n\\[ \\mathsf{f(x) = \\sin(3x) + 2x} \\]\nDie Ableitung wird an der Stelle \\(\\mathsf{x_0 = 0.85}\\) angenähert.\n\ndef fkt(x):\n    return np.sin(3*x) + 2*x\n\n# Daten für die Visualisierung\nx = np.linspace(0, 2, 100)\ny = fkt(x)\n\n# Exakte Lösung bei x=0.85\nfp_exakt = 3*np.cos(3*0.85) + 2\n\n\n# Entwicklungspunkt und Schrittweite\nh = 0.25\nx0 = 0.85\n\n# Auswertung an den beiden Stellen\nf0 = fkt(x0)\nfh = fkt(x0 + h)\n\n# Bestimmung der Ableitungsnäherung\nfp = (fh - f0) / h\n\n\nprint(f\"Die numerische Näherung der Ableitung an der Stelle {x0:.2f}:\")\nprint(f\"Näherung mit Schrittweite {h:.2f}: {fp:.2f}\")\nprint(f\"Exakter Wert: {fp_exakt:.2f}\")\n\nDie numerische Näherung der Ableitung an der Stelle 0.85:\nNäherung mit Schrittweite 0.25: -0.86\nExakter Wert: -0.49\n\n\nDie Methode kann auch graphisch dargestellt werden. Die gesuchte Steigung ist die Steigung der eingezeichneten Geraden.\n\nplt.plot(x, y, label=\"Funktion\")\nplt.scatter([x0], [f0], color='C3', label='Entwicklungspunkt', zorder=3)\nplt.scatter([x0+h], [fh], color='C4', label='Auswertepunkte', zorder=3)\n\nplt.vlines(x0, ymin=0, ymax=f0, color='C3', alpha=0.5)\n\nplt.plot(x, f0 + fp*(x-x0), label='Differenzenformel')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.grid()\nplt.legend(bbox_to_anchor=(1.05, 1.0), loc='upper left');\n\n\n\n\n\n\n\n\n\n\n35.2.2 Erste Ableitung zweiter Ordnung\nMit dem gleichen Ansatz kann auch eine Differenzenformel zweiter Ordnung gefunden werden. Dazu wird die Funktion an den Stellen \\(\\mathsf{x_0-h}\\) und \\(\\mathsf{x_0+h}\\) mit der Taylor-Reihe bis zur Ordnung \\(\\mathsf{\\mathcal{O}(h^3)}\\) approximiert.\n\\[\\mathsf{f(x_0+h) = f(x_0) + f'(x_0)\\cdot h + \\frac{1}{2}f''(x_0)\\cdot h^2 + \\mathcal{O}(h^3)} \\] \\[\\mathsf{f(x_0-h) = f(x_0) - f'(x_0)\\cdot h + \\frac{1}{2}f''(x_0)\\cdot h^2 + \\mathcal{O}(h^3)} \\]\nDie Differenz dieser beiden Gleichungen führt zu\n\\[\\mathsf{f(x_0+h) - f(x_0-h) = 2f'(x_0)\\cdot h + \\mathcal{O}(h^3)} \\]\nUnd die Umformung nach der gesuchten Ableitung an der Stelle \\(\\mathsf{x_0}\\) ergibt\n\\[\\mathsf{f'(x_0) = \\frac{f(x_0+h) - f(x_0-h)}{2h} + \\mathcal{O}(h^2)} \\]\nDies ist die zentrale Differenzenformel für die erste Ableitung zweiter Ordnung. Wie bei der vorwärtsgerichteten Formel muss hier die Funktion an zwei Stellen ausgewertet werden, jedoch nicht mehr am Entwicklungspunkt selbst. Durch diese Symmetrie bzgl. des Entwicklungspunkts ergibt sich ein besseres, hier quadratisches, Konvergenzverhalten.\n\n# Auswertung an den beiden Stellen\nfnh = fkt(x0 - h)\nfph = fkt(x0 + h)\n\n# Bestimmung der Ableitungsnäherung\nfp = (fph - fnh) / (2*h)\n\n\nprint(f\"Die numerische Näherung der Ableitung an der Stelle {x0:.2f}:\")\nprint(f\"Näherung mit Schrittweite {h:.2f}: {fp:.2f}\")\nprint(f\"Exakter Wert: {fp_exakt:.2f}\")\n\nDie numerische Näherung der Ableitung an der Stelle 0.85:\nNäherung mit Schrittweite 0.25: -0.26\nExakter Wert: -0.49\n\n\nDie Methode kann auch graphisch dargestellt werden. Die gesuchte Steigung ist die Steigung der eingezeichneten Geraden.\n\nplt.plot(x, y, label=\"Funktion\")\nplt.scatter([x0], [f0], color='C3', label='Entwicklungspunkt', zorder=3)\nplt.scatter([x0-h, x0+h], [fnh, fph], color='C4', label='Auswertepunkte', zorder=3)\n\nplt.vlines(x0, ymin=0, ymax=f0, color='C3', alpha=0.5)\n\nplt.plot(x, fnh + fp*(x-x0+h), label='Differenzenformel')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.grid()\nplt.legend(bbox_to_anchor=(1.05, 1.0), loc='upper left');",
    "crumbs": [
      "Numerik",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Differentiation</span>"
    ]
  },
  {
    "objectID": "books/numerik/skript/intro_ableitungen.html#zweite-ableitung-zweiter-ordnung",
    "href": "books/numerik/skript/intro_ableitungen.html#zweite-ableitung-zweiter-ordnung",
    "title": "35  Differentiation",
    "section": "35.3 Zweite Ableitung zweiter Ordnung",
    "text": "35.3 Zweite Ableitung zweiter Ordnung\nMit dem gleichen Schema wie oben, kann auch die Differenzenformel für die zweite Ableitung bestimmt werden. Diese lautet\n\\[\\mathsf{f''(x_0) = \\frac{f(x_0-h) - 2f(x_0) + f(x_0+h)}{h^2} + \\mathcal{O}(h^2)}\\]",
    "crumbs": [
      "Numerik",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Differentiation</span>"
    ]
  },
  {
    "objectID": "books/numerik/skript/intro_ableitungen.html#fehlerbetrachtung",
    "href": "books/numerik/skript/intro_ableitungen.html#fehlerbetrachtung",
    "title": "35  Differentiation",
    "section": "35.4 Fehlerbetrachtung",
    "text": "35.4 Fehlerbetrachtung\nIn diesem Abschnitt werden die Approximationsfehler, d.h. Fehler aus der Differenzenformeln, und Rundungsfehler, d.h. Fehler durch die endliche Genauigkeit der digitalen Darstellung von Zahlen, betrachtet.\n\n35.4.1 Approximationsfehler\nDie Ordnung des Verfahrens kann durch die Betrachtung des Fehlers, hier zum bekannten exakten Wert, bestimmt werden. Dazu wird die Schrittweite kontinuierlich verkleinert.\n\n\nCode\ndef fkt(x):\n    return np.sin(3*x) + 2*x\n\n# Daten für die Visualisierung\nx = np.linspace(0, 2, 100)\ny = fkt(x)\n\n# Exakte Lösung bei x=1\nfp_exakt = 3*np.cos(3*0.85) + 2\n\n\n\n\nCode\nx0 = 0.85\n\nhs = []\nfpfs = []\nfpcs = []\n\n\nh0 = 1\nfor i in range(18):\n    h = h0 / 2**i\n\n    f0 = fkt(x0)\n    fnh = fkt(x0 - h)\n    fph = fkt(x0 + h)\n\n    fpf = (fph - f0) / h\n    fpc = (fph - fnh) / (2*h)\n    \n    hs.append(h)\n    fpfs.append(fpf)\n    fpcs.append(fpc)\n\n\n\n\nCode\nplt.plot(hs, np.abs(fpfs - fp_exakt), label='vorwärts')\nplt.plot(hs, np.abs(fpcs - fp_exakt), label='zentral')\n\nplt.plot([1e-5, 1e-1], [1e-5, 1e-1], '--', color='grey', label='Hilfslinien')\nplt.plot([1e-5, 1e-1], [1e-10, 1e-2], '--', color='grey')\n\nplt.xlabel('Schrittweite h')\nplt.ylabel('Fehler')\n\nplt.xscale('log')\nplt.yscale('log')\n\nplt.legend()\nplt.grid();\n\n\n\n\n\n\n\n\n\nIn der logiarithmischen Darstellung beider Achsen werden Potenzfunktionen zu Graden mit dem Potenzgrad als Steigung. Das bedeutet, dass der Fehler im obigen Plot sich wie eine Potenzfunktion mit dem Grad eins bzw. zwei verhält. Die eingezeichneten Hilfslinien haben eine Steigung von eins bzw. zwei. Dies entspricht auch der Ordnung \\(\\mathsf{\\mathcal{O}(h)}\\) bzw. \\(\\mathsf{\\mathcal{O}(h^2)}\\) aus der Differenzenformel.\n\n\n35.4.2 Rundungsfehler\nWird nun die Schrittweiter noch weiter verkleinert, wirkt sich die Genauigkeit der Darstellung von Zahlen bzw. Rundungsfehler auf die Approximation aus.\n\n\nCode\nx0 = 0.85\n\nhs = []\nfpfs = []\nfpcs = []\n\n\nh0 = 1\nfor i in range(35):\n    h = h0 / 2**i\n\n    f0 = fkt(x0)\n    fnh = fkt(x0 - h)\n    fph = fkt(x0 + h)\n\n    fpf = (fph - f0) / h\n    fpc = (fph - fnh) / (2*h)\n    \n    hs.append(h)\n    fpfs.append(fpf)\n    fpcs.append(fpc)\n\n\n\n\nCode\nplt.plot(hs, np.abs(fpfs - fp_exakt), label='vorwärts')\nplt.plot(hs, np.abs(fpcs - fp_exakt), label='zentral')\n\nplt.plot([1e-5, 1e-1], [1e-5, 1e-1], '--', color='grey', label='Hilfslinien')\nplt.plot([1e-5, 1e-1], [1e-10, 1e-2], '--', color='grey')\n\nplt.xlabel('Schrittweite h')\nplt.ylabel('Fehler')\n\nplt.xscale('log')\nplt.yscale('log')\n\nplt.legend()\nplt.grid();\n\n\n\n\n\n\n\n\n\nWie bereits vorgestellt, können 64-Bit-Zahlen nur mit einer Genauigkeit von etwa \\(\\mathsf{\\epsilon\\approx10^{-16}}\\) dargestellt werden. Das bedeutet, dass z.B. die Differenz von zwei Zahlen nicht genauer als \\(\\mathsf{\\epsilon}\\) berechnet werden kann. Dies ist der sogenannte Rundungsfehler.\nIm konkreten Fall der Vorwärtsdifferenzenformel bedeutet dies:\n\\[ \\mathsf{f'(x_0) = \\frac{f(x_0 + h) - f(x_0)}{h} + \\mathcal{O}(h)} \\] \\[\\mathsf{\\overset{Rundungsfehler}{\\Rightarrow} \\frac{f(x_0 + h) - f(x_0) + \\mathcal{O}(\\epsilon)}{h} + \\mathcal{O}(h)} \\] \\[ \\mathsf{= \\frac{f(x_0 + h) - f(x_0)}{h} + \\mathcal{O}\\left(\\frac{\\epsilon}{h}\\right) + \\mathcal{O}(h)} \\]\nDamit macht eine Verkleinerung von \\(\\mathsf{h}\\) nur Sinn, solange der Rundungsfehler klein gegenüber \\(\\mathsf{h}\\) ist. Genauer:\n\\[\\mathsf{\\frac{\\epsilon}{h} \\le h }\\] \\[\\mathsf{\\Rightarrow \\quad h \\ge \\sqrt{\\epsilon}} \\]\nMit \\(\\mathsf{\\epsilon \\approx 10^{-16}}\\) ist für diese Differenzenformel ein \\(\\mathsf{h}\\) nur bis etwa \\(\\mathsf{10^{-8}}\\) angemessen.",
    "crumbs": [
      "Numerik",
      "<span class='chapter-number'>35</span>  <span class='chapter-title'>Differentiation</span>"
    ]
  }
]