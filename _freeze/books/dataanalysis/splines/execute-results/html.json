{
  "hash": "6685ef00e45e27f2219bc10973c112e5",
  "result": {
    "engine": "jupyter",
    "markdown": "# Splines\n\n\n\nPolynominterpolation versucht eine globale Modellfunktion zu finden. Jedoch eignen sich Polynome mit hohen Graden im Allgemeinen nicht für eine Interpolation vieler Punkte. Einen anderen Ansatz verfolgen Splines. Diese sind Polynomzüge, welche die einzelnen Messpunkte verbinden und deren Grad klein – typischerweise zwischen eins und drei – ist. \n\n## Definition\n\nFür $n+1$ Messpunkte $(x_i, y_i)$ kann eine Splinefunktion $s_k$, hier ein Polynomspline, wie folgt definiert werden.\n\n* Vorausgesetzt ist, dass die Messpunkte sortiert sind, d.h. $x_0 < x_1 < \\cdots < x_n$\n* für jedes $i = 0\\dots n − 1$ ist $s_k$ ein Polynom vom Grad $k$ auf dem Intervall $\\left[x_i , x_{i+1}\\right]$\n* $s_k$ ist auf $\\left[x_0 , x_n \\right]$ $(k − 1)$-mal stetig differenzierbar\n\nBeispiele:\n* $k = 1$: Polygonzug\n* $k = 3$: kubische Polynomsplines (B-Splines)\n\n## Kubische Splines\n\nDie in der Praxis häufig eingesetzten kubischen Polynomsplines $s_3$ ($ k= 3$) haben folgende Eigenschaften:\n* $s_3|\\left[x_i,x_{i+1}\\right] = \\beta_0 +\\beta_1 x + \\beta_2 x^2 + \\beta_3 x^3$\n* $s_3$ ist zweimal stetig differenzierbar auf $\\left[x_0,x_n\\right]$, also insbesondere an den\nStützpunkten $x_i$ der Messpunkte \n\nDie Koeffizienten $\\beta_i$ werden wie folgt bestimmt\n* aus den $n + 1$ Messpunkten ergeben sich $n$ Intervalle, d.h. mit jeweils vier Koeffizienten sind es insgesamt $4n$ Koeffizienten\n* Exakte Darstellung der Messpunkte ($ n + 1$ Gleichungen), d.h.: $s_3(x_i) = y_i$\n* Glattheitsbedingungen an den inneren Messpunkten ($ i=1\\dots n-1$), mit jeweils ($ n − 1$ Gleichungen):\n$$ s_3'(x_i)_- =s_3'(x_i)_+$$\n$$ s_3''(x_i)_- =s_3''(x_i)_+$$\n$$ s_3'''(x_i)_- =s_3'''(x_i)_+$$\n\n* Damit sind es $4n − 2$ Gleichungen für $4n$ Koeffizienten\n\nUm die beiden fehlenden Gleichungen zu finden bzw. zu bestimmen werden Randbedingungen oder Abschlussbedingungen benötigt.\nDie gängigsten Bedingungen sind:\n* natürliche Splines: die Krümung am Rand verschwindet, d.h.:\n$$ s_3''(x_0) = s_3''(x_n) = 0 $$\n* periodische Splines: die Steigung und Krümung ist an beiden Rändern gleich\n$$ s_3'(x_0) = s_3'(x_n)$$ \n$$ s_3''(x_0) = s_3''(x_n)$$\n* Hermite Splines: die Steigungen am Rand werden explizit vorgegeben (hier durch $u$ und $v$)\n$$ s_3'(x_0) = u $$\n$$ s_3'(x_n) = v $$\n\n## Anwendung\n\nIm Folgenden werden zwei Beispiele, $s_1$ und $s_3$, für die Erstellung von Splines mit Python vorgestellt. \n\n::: {#28c2f6c6 .cell execution_count=2}\n``` {.python .cell-code}\n# Erzeugung von Messpunkten\nn = 7\nxi = np.linspace(0, np.pi, n)\nyi = np.sin(xi)\n```\n:::\n\n\nFür die $s_1$ Splines, kann die Funktion `np.interp` verwendet werden. Sie führt eine lineare Interpolation zwischen gegebenen Wertepaaren durch.\n\n::: {#b36cedd6 .cell execution_count=3}\n``` {.python .cell-code}\n# Wertebereich für die Visualisierung der Interpolation\nx = np.linspace(0, np.pi, n*6)\ny = np.sin(x)\n```\n:::\n\n\n::: {#415b69b9 .cell execution_count=4}\n``` {.python .cell-code}\n# Interpolation\ny_s1 = np.interp(x, xi, yi)\n```\n:::\n\n\n::: {#53886442 .cell execution_count=5}\n``` {.python .cell-code}\nplt.plot(x,y, alpha=0.3, color='C2', lw=5, \n         label='Generierende Funktion')\nplt.plot(x, y_s1, color='C0', label='Interpolation')\nplt.scatter(x, y_s1, s=3, zorder=3, color='C0')\nplt.scatter(xi, yi, color='C1', label='Messpunkte')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](splines_files/figure-html/cell-6-output-1.png){width=589 height=429}\n:::\n:::\n\n\nDie $s_3$ Splines können mit Funktionen aus dem scipy-Modul berechnet werden. Dazu werden zunächst die Koeffizienten bestimmt (`scipy.interpolate.splrep`) und diese ermöglichen die gewünschte Auswertung, welche mit der Funktion `scipy.interpolate.splev` vorgenommen werden kann. \n\n::: {#0aff4527 .cell execution_count=6}\n``` {.python .cell-code}\nimport scipy.interpolate as si\n```\n:::\n\n\n::: {#36b42131 .cell execution_count=7}\n``` {.python .cell-code}\ns3 = si.splrep(xi, yi)\ny_s3 = si.splev(x, s3)\n```\n:::\n\n\n::: {#19a8981c .cell execution_count=8}\n``` {.python .cell-code}\nplt.plot(x,y, alpha=0.3, color='C2', lw=5, \n         label='Generierende Funktion')\nplt.plot(x, y_s3, color='C0', label='Interpolation')\nplt.scatter(x, y_s3, s=3, zorder=3, color='C0')\nplt.scatter(xi, yi, color='C1', label='Messpunkte')\n\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend();\n```\n\n::: {.cell-output .cell-output-display}\n![](splines_files/figure-html/cell-9-output-1.png){width=589 height=429}\n:::\n:::\n\n\n",
    "supporting": [
      "splines_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}