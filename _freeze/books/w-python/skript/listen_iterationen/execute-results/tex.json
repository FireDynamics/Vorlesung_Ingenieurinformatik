{
  "hash": "154fb20fbb99b0ab7a14b89061a783a9",
  "result": {
    "engine": "jupyter",
    "markdown": "# Einf√ºhrung: Mehrere Werte speichern\n\nBisher haben Sie einzelne Werte in Variablen gespeichert. Doch was, wenn Sie eine ganze Reihe von Zahlen, Namen oder Werten auf einmal speichern m√∂chten?\n\nDaf√ºr gibt es in Python **Listen**. In diesem Kapitel lernen Sie au√üerdem, wie man mit `for`-Schleifen √ºber Listen iteriert.\n\n## Was ist eine Liste?\n\nEine Liste ist eine geordnete Sammlung von Werten.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nnamen = [\"Ali\", \"Bente\", \"Carlos\"]\nnoten = [1.7, 2.3, 1.3, 2.0]\n```\n:::\n\n\nAuf Elemente greifen Sie mit eckigen Klammern zu:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nprint(namen[0])  # erstes Element\nprint(noten[-1]) # letztes Element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAli\n2.0\n```\n:::\n:::\n\n\n## Teile aus Listen ausschneiden ‚Äì Slicing\n\nMit dem sogenannten **Slicing** k√∂nnen Sie gezielt Ausschnitte aus einer Liste entnehmen. Dabei geben Sie an, **wo der Ausschnitt beginnt und wo er endet** (der Endwert wird **nicht** mehr mitgenommen):\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nzahlen = [10, 20, 30, 40, 50, 60]\nprint(zahlen[1:4])  # Ausgabe: [20, 30, 40]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[20, 30, 40]\n```\n:::\n:::\n\n\n### üî¢ Syntax: `liste[start:stop]`\n\n- **start**: Index, bei dem das Slicing beginnt (inklusive)\n- **stop**: Index, an dem es endet (exklusive)\n- Der Startwert kann auch weggelassen werden: `[:3]` ‚Üí erstes bis drittes Element\n- Ebenso der Endwert: `[3:]` ‚Üí ab dem vierten Element bis zum Ende\n- Ganze Kopie: `[:]`\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nprint(zahlen[:3])   # [10, 20, 30]\nprint(zahlen[3:])   # [40, 50, 60]\nprint(zahlen[:])    # vollst√§ndige Kopie\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10, 20, 30]\n[40, 50, 60]\n[10, 20, 30, 40, 50, 60]\n```\n:::\n:::\n\n\nüí° Sie k√∂nnen auch mit negativen Indizes arbeiten (`-1` ist das letzte Element):\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint(zahlen[-3:])  # [40, 50, 60]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[40, 50, 60]\n```\n:::\n:::\n\n\n## √úber Listen iterieren\n\nMit einer `for`-Schleife k√∂nnen Sie √ºber jedes Element in einer Liste iterieren:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nnamen = [\"Ali\", \"Bente\", \"Carlos\"]\n\nfor name in namen:\n    print(\"Hallo\", name + \"!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHallo Ali!\nHallo Bente!\nHallo Carlos!\n```\n:::\n:::\n\n\n## Erweiterung: Bedingte Ausgaben\n\nSie k√∂nnen in der Schleife mit `if` filtern:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ntemperaturen = [14.2, 17.5, 19.0, 21.3, 18.4]\n\nfor t in temperaturen:\n    if t > 18:\n        print(t, \"ist ein warmer Tag\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n19.0 ist ein warmer Tag\n21.3 ist ein warmer Tag\n18.4 ist ein warmer Tag\n```\n:::\n:::\n\n\n## Durchschnitt berechnen\n\nPython stellt n√ºtzliche Funktionen bereit, z.‚ÄØB. `sum()` und `len()`:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nnoten = [1.7, 2.3, 1.3, 2.0]\n\ndurchschnitt = sum(noten) / len(noten)\nprint(\"Durchschnittsnote:\", round(durchschnitt, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDurchschnittsnote: 1.82\n```\n:::\n:::\n\n\n## Listen erweitern: `.append()`\n\nManchmal kennen Sie die Listenelemente nicht vorher ‚Äì dann k√∂nnen Sie neue Werte **nachtr√§glich hinzuf√ºgen**:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nnamen = []\n\nnamen.append(\"Ali\")\nnamen.append(\"Bente\")\n\nprint(namen)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Ali', 'Bente']\n```\n:::\n:::\n\n\nüí° Die Methode `.append(...)` h√§ngt einen neuen Wert an das Ende der Liste.\n\n## Verschachtelte Schleifen\n\nWenn Sie mit **mehrdimensionalen Daten** arbeiten ‚Äì z.‚ÄØB. eine Tabelle mit mehreren Zeilen ‚Äì k√∂nnen Sie Schleifen **ineinander verschachteln**:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nwochentage = [\"Mo\", \"Di\", \"Mi\"]\nstunden = [1, 2, 3]\n\nfor tag in wochentage:\n    for stunde in stunden:\n        print(f\"{tag}, Stunde {stunde}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMo, Stunde 1\nMo, Stunde 2\nMo, Stunde 3\nDi, Stunde 1\nDi, Stunde 2\nDi, Stunde 3\nMi, Stunde 1\nMi, Stunde 2\nMi, Stunde 3\n```\n:::\n:::\n\n\nDas ergibt:\n\n```\nMo, Stunde 1\nMo, Stunde 2\nMo, Stunde 3\nDi, Stunde 1\n...\n```\n\n## Listen sortieren\n\nMit `sorted(...)` k√∂nnen Sie Listen **alphabetisch oder numerisch sortieren**:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nnamen = [\"Zoe\", \"Anna\", \"Ben\"]\nsortiert = sorted(namen)\n\nprint(sortiert)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Anna', 'Ben', 'Zoe']\n```\n:::\n:::\n\n\nüí° Die Original-Liste bleibt **unver√§ndert**.  \nWenn Sie die Liste direkt ver√§ndern m√∂chten, geht das mit:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nnamen.sort()\n```\n:::\n\n\n",
    "supporting": [
      "listen_iterationen_files/figure-pdf"
    ],
    "filters": []
  }
}