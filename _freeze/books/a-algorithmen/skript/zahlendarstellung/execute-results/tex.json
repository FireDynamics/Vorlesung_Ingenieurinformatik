{
  "hash": "0c0ac5d550122768cb74107c6fcdb2ae",
  "result": {
    "engine": "jupyter",
    "markdown": "# Exkurs: Interne Darstellung von Zahlen und Zeichen\n\n\n\nDie Grundlage für alle modernen Computer ist die \n[Digitalisierung](https://de.wikipedia.org/wiki/Digitalisierung). Diese \nermöglicht es reale Informationen, Kommunikationsformen oder Anweisungen \nals eine Folge von zwei Zuständen 1/0 darzustellen. Computersysteme nutzen \ndiese Reduktion bzw. Vereinfachung auf nur zwei Zustände zum Speichern, \nÜbertragen und Verarbeiten von Daten.\n\n## Analoge und digitale Signale\n\nIn der Technik unterscheidet man grundsätzlich zwischen **analogen** und \n**digitalen Signalen**, wenn Informationen dargestellt, verarbeitet oder \nübertragen werden.\n\n### Analoge Signale\n\nEin analoges Signal ist **kontinuierlich** in Zeit und Ausprägung. Es kann \nunendlich viele Werte innerhalb eines Bereichs annehmen – wie z. B. die Spannung \neines Mikrofonsignals, die mit der Lautstärke variiert, oder die Temperatur, \ndie sich stetig verändert.  \n\nAnaloge Signale sind gut geeignet, um natürliche Phänomene direkt abzubilden, \nsind aber anfällig für Störungen und schwer exakt zu speichern oder \nweiterzuverarbeiten.\n\n### Digitale Signale\n\nEin digitales Signal besteht aus **diskreten Werten** – meist zwei: 0 und 1. Es \nwird also in einzelnen Schritten dargestellt und ist damit für Computer besonders \ngut geeignet. Die kontinuierlichen Werte der realen Welt müssen dafür zunächst \nin digitale Werte **umgewandelt** werden (Analog-Digital-Wandlung).\n\nDigitale Signale lassen sich fehlerfrei speichern, übertragen und beliebig oft \nkopieren, ohne dass die Information an Qualität verliert.\n\n### Vergleich: Analoge vs. digitale Signale\n\n| Merkmal                   | Analoge Signale                              | Digitale Signale                              |\n|---------------------------|----------------------------------------------|-----------------------------------------------|\n| Signalverlauf             | Stetig, kontinuierlich                       | Diskret, stufenweise                          |\n| Wertebereich              | Unendlich viele Werte innerhalb eines Bereichs | Endliche Anzahl (z. B. 0 und 1)               |\n| Störanfälligkeit          | Hoch – kleine Störungen wirken sich direkt aus | Gering – durch Fehlerkorrektur ausgleichbar  |\n| Speicherung               | Schwierig, da kontinuierlich                 | Einfach und verlustfrei möglich               |\n| Verarbeitung              | Aufwendig, da kontinuierlich                 | Effizient durch digitale Logik                |\n| Beispiel                  | Plattenspieler, Thermometer mit Zeiger       | MP3-Datei, Digitalkamera                      |\n\n### Umwandlung analoger zu digitaler Signale\nUm aus analogen Werten, z.B. aus einem Experiment, digitale Werte für die Auswertung z\nu gewinnen, werden Analog-Digital-Wandler (ADC) genutzt. Einfach gesagt, tastet ein \nADC ein Signal mit einer vorgegebenen (endlichen) Abtastrate ab. Dabei wird der \nSignalwert einem der (endlich vielen) vorgegebenen Werteintervalle zugeordnet. \nFolgende Abbildung zeigt ein Beispiel für die Umwandlung eines analogen Signals \n(blaue Kurve) in ein digitales (orangene Punkte). Hier ist das Abtastintervall im \nZeit- und Wertbereich jeweils Eins, in der Abbildung durch das graue Gitter \nveranschaulicht. Damit kann die vom ADC ermittelte Folge von Werten nur Punkte \nauf dem Gitter enthalten.\n\n::: {.cell execution_count=2}\n\n::: {.cell-output .cell-output-display}\n![Umwandlung eines digitalen (blau) zu einem analogen Signal (orange)](zahlendarstellung_files/figure-pdf/fig-transform_digital_analog-output-1.pdf){#fig-transform_digital_analog}\n:::\n:::\n\n\n## Digitale Zahlendarstellung\n\nIn den vorherigen Abschnitten haben wir gesehen, wie analoge Informationen in \ndigitale Signale umgewandelt werden können. Damit ein Computer solche digitalen \nInformationen verarbeiten kann, müssen sie intern als **Zahlen** dargestellt \nwerden - und zwar in einem für Computer verständlichen Format: dem **Binärsystem**.\n\nWir beschäftigen uns in diesem Abschnitt daher mit der Frage, wie \nZahlen **intern gespeichert und dargestellt** werden. Dabei lernen wir \nunter anderem:\n\n- Wie Zahlen in **verschiedenen Zahlensystemen** dargestellt werden können (z. B. Binär, Dezimal, Hexadezimal),\n- wie man zwischen diesen Systemen **umrechnet**,\n- und wie man solche Umrechnungen auch **algorithmisch** beschreiben und in Code umsetzen kann.\n\n### Dualsystem\nDa in der digitalen Elektronik nur mit zwei Zuständen gerechnet wird, bietet sich das [Dualsystem](https://de.wikipedia.org/wiki/Dualsystem), auch genannt Binärsystem, zur Zahlendarstellung an.\nBeispiele für Zahlendarstellungen zur Basis 2, wobei der Index die Basis angibt:\n\n* 5<sub>10</sub> = 101<sub>2</sub>\n* 107<sub>10</sub> = 1101011<sub>2</sub>\n* 2635<sub>10</sub> = 101001001011<sub>2</sub>\n\nDamit lassen sich Zahlen als eine Reihe bzw. Abfolge von `0`/`1`-Zuständen darstellen.\n\n### Hexadezimalsystem\n\nBei Zahlen zur Basis 16 müssen auch Stellen, welche größer als 9 sind, \nabgebildet werden. Hierzu werden Buchstaben eingesetzt, um die Ziffern \n'10', dargestellt durch `A`, bis '15' (`F`) abzubilden. Eine oft verwendete \nSchreibweise für Zahlen im Hexadezimalsystem ist das Vorstellen von `0x` vor \ndie Zahl, wie im folgenden Beispielen gezeigt:  \n\n* 5<sub>10</sub> = 5<sub>16</sub> = 0x5\n* 107<sub>10</sub> = 6B<sub>16</sub> = 0x6B\n* 2635<sub>10</sub> = A4B<sub>16</sub> = 0xA4B\n\n## Binäre Maßeinheiten\n\nDa sich in der digitalen Welt alles um Potenzen von 2 dreht, haben sich aus technischen Gründen folgende Einheiten ergeben:\n\n* 1 Bit = eine Ziffer im Binärsystem, Wertebereich: 0 und 1 \n* 1 Byte = acht Ziffern im Binärsystem, Wertebereich: 0 bis 255\n\nUm größere Datenmengen praktischer anzugeben, werden folgende Einheiten genutzt:\n\n* 1 KB = 1 kiloByte = 10<sup>3</sup> Byte\n* 1 MB = 1 megaByte = 10<sup>6</sup> Byte \n* 1 GB = 1 gigaByte = 10<sup>9</sup> Byte \n* 1 TB = 1 teraByte = 10<sup>12</sup> Byte \n* 1 PB = 1 petaByte = 10<sup>15</sup> Byte\n\n## Geschwindigkeit der Datenübertragung\n\nDie Geschwindigkeit mit der Daten übertragen werden können wird als Datenmenge pro Zeit angegeben. Hierbei wird die Zeit meist auf eine Sekunde bezogen. Beispielhaft sind hier einige Datenübertragungsraten beim Zugriff auf eine [magnetische Festplatte (HDD)](https://de.wikipedia.org/wiki/Festplattenlaufwerk) und auf ein [Halbleiterlaufwerk (SSD)](https://de.wikipedia.org/wiki/Solid-State-Drive) aufgeführt.\n\n* Lesen / Schreiben HDD: ~200 MB/s \n* Lesen / Schreiben SSD: ~500 MB/s\n\nAls weiteres Beispiel können maximale Übertragunsraten in verschiedenen Netzwerken genannt werden:\n\n* über das Mobilfunknetz, z.B. [3G](https://de.wikipedia.org/wiki/Mobilfunkstandard): 384 kbit/s\n* über ein Netzwerkkabel, z.B. [Fast Ethernet](https://de.wikipedia.org/wiki/Ethernet): ~100 Mbit/s\n\n## Darstellung ganzer Zahlen\n\nDie Grundidee bei der digitalen Darstellung von Zahlen, hier ganze Zahlen, ist die Verwendung einer festen Anzahl von Bits. Diese bilden dann eine entsprechende Anazahl von Stellen im Dualsystem ab. Dieser Idee folgend, kann eine ganze Zahl mit Vorzeichen wie folgt als 8-Bit-Zahl dargestellt werden:\n\n![Bitzuordnung bei der Darstellung einer ganzen Zahl mit 8 Bit.](00-bilder/zahlendarstellung_integer08.svg)\n\nFür zwei Zahlen aus dem obigen Beispiel für die Zahldarstellung im Dualsystem könnte die Bitzuweisung wie folgt aussehen.\n\n![Beispiel der Bitzuordnung für die Zahl 5 mit 8 Bit.](00-bilder/zahlendarstellung_integer08_5.svg)\n\n![Beispiel der Bitzuordnung für die Zahl 107 mit 8 Bit.](00-bilder/zahlendarstellung_integer08_107.svg)\n\n\nDurch die fixe Vorgabe der Stellen im Dualsystem, also hier der Bits, ergibt sich der Zahlenbereich, welcher mit diesen Bits abgebildet werden kann. Für die Darstellung von ganzen Zahlen mit 8 Bit, also mit einem Byte, ergibt sich somit\n\n* kleinste Zahl: 0<sub>2</sub> = 0\n* größte Zahl: 11111111<sub>2</sub> = 2<sup>8</sup>-1 = 255 .\n\nNatürlich können auch länger Bitfolgen für einen größeren Zahlenbereich genutzt werden. Zusätzlich kann eines der Bits auch genutzt werden, um das Vorzeichen darzustellen. Folgende Abbildung zeigt die Darstellung einer vorzeichenbehafteten ganzen Zahl mit 32 Bit.\n\n![Bitzuordnung bei der Darstellung einer ganzen Zahl samt Vorzeichen mit 32 Bit.](00-bilder/zahlendarstellung_integer32.svg)\n\nDer Wertebereich ist in diesem Fall gegeben durch:\n\n* kleinste Zahl = -2<sup>31</sup> = -2,147,483,648\n* größte Zahl =  2<sup>31</sup> - 1 = 2,147,483,647 .\n\nIn der Informatik wird solch eine Darstellung von ganzen Zahlen als [Integer Datentyp](https://de.wikipedia.org/wiki/Integer_(Datentyp)) bezeichnet. Im Englischen wird dieser als *integer* bezeichnet.\n\n## Umrechnung zwischen Dezimal- und Binärzahlen\n\nUm zwischen **Dezimalzahlen (zur Basis 10)** und **Binärzahlen (zur Basis 2)** umzuwandeln, gibt es jeweils einfache Verfahren. Diese lassen sich auch leicht als Algorithmus in Programmiersprachen umsetzen.\n\n### Von Binär nach Dezimal\n\nEine Binärzahl besteht aus einzelnen Stellen (Bits), die jeweils eine Potenz von 2 repräsentieren. Zur Umrechnung summiert man die Produkte der Ziffern mit ihrer jeweiligen Stellenwertigkeit:\n\n$$\nz = \\sum_{i=0}^{n} b_i \\cdot 2^i\n$$\n\nDabei ist:\n- \\( b_i \\in \\{0, 1\\} \\) das i-te Bit (von rechts gezählt),\n- \\( 2^i \\) der Stellenwert der Position,\n- \\( z \\) die Dezimalzahl.\n\n**Beispiel**:  \nUmwandlung von \\( 1011_2 \\) nach Dezimal:\n\n\\[\n\\begin{align*}\n1011_2 &= 1 \\cdot 2^3 + 0 \\cdot 2^2 + 1 \\cdot 2^1 + 1 \\cdot 2^0 \\\\\n       &= 8 + 0 + 2 + 1 = 11_{10}\n\\end{align*}\n\\]\n\n### Von Dezimal nach Binär\n\nZur Umwandlung einer Dezimalzahl in eine Binärzahl verwendet man die **ganzzahlige Division durch 2**. Der jeweilige Rest (0 oder 1) ergibt die Binärziffer. Man wiederholt diesen Vorgang so lange, bis der Quotient 0 ist, und liest die Reste **von unten nach oben**.\n\n**Beispiel**:  \nUmwandlung von $11_{10}$ nach Binär:\n\n$$\n\\begin{array}{rcl}\n11 \\div 2 &= 5 &\\text{Rest } 1 \\\\\n5 \\div 2  &= 2 &\\text{Rest } 1 \\\\\n2 \\div 2  &= 1 &\\text{Rest } 0 \\\\\n1 \\div 2  &= 0 &\\text{Rest } 1 \\\\\n\\end{array}\n$$\n\n→ Von unten gelesen ergibt das: $1011_2$\n\n::: {.callout-note title=\"Merke\"}\nDie Umrechnung funktioniert immer, egal wie groß die Zahl ist – sie ist eine systematische Anwendung der Stellenwertsysteme. Computer arbeiten intern genau auf diese Weise, nur in Hardware.\n:::\n\n## Darstellung reeller Zahlen\n\nReelle Zahlen können nur angenährt als eine [Gleitkommazahl](https://de.wikipedia.org/wiki/Gleitkommazahl) digital dargestellt werden. Dazu wir die zur Verfügung stehende Menge an Bits auf folgende Zuordnungen aufgeteilt: Vorzeichen $\\mathsf s$, Exponent $\\mathsf e$ und Mantisse $\\mathsf m$. Jedem dieser Bereiche wird eine feste Anzahl von Bits zugeordnet wodruch sich der Wertebereich und Genauigkeit der Darstellung ergibt. Im Allgemeinen kann somit eine Gleitkommazahl dargestellt werden als\n\n$$ \\mathsf z = (-1)^s \\cdot m \\cdot 2^e .$$\n\nEs existieren mehrere Ansätze für die Abbildung von Gleitkommazahlen. Insbesondere im [IEEE754 Standard](https://de.wikipedia.org/wiki/IEEE_754) wird folgende Aufteilung definiert: Vorzeichen (1 bit), Exponent (11 bit) und Mantisse (52 bit):\n\n![Bitzuordnung bei der Darstellung einer reellen Zahl mit 64 bit.](00-bilder/zahlendarstellung_float.svg)\n\nAus der obigen Festlegung der Bitzuweisung, ergeben sich die Größenordnung für den Wertebereich, welcher durch den Exponenten vorgegeben ist. Um auch Zahlen kleiner 1 darstellen zu können, kann der Exponent $\\mathsf e$ auch negative Werte annehmen.\n\nFür den Exponenten $\\mathsf e$ gilt\n\n* kleinster Wert in Etwa: -(2<sup>10</sup> - 1) = -1023\n* größter Wert in Etwa: ~ 2<sup>10</sup> - 1 = 1023 .\n\nOhne Beachtung der Mantisse und des Vorzeichens, ergibt sich mit den obigen Werten dieser Bereich für die Größenordnungen:\n\n* kleinste Größenordnung: 2<sup>-1023</sup> ~ 10<sup>-308</sup>\n* größte Größenordnung: 2<sup>1023</sup> ~ 10<sup>308</sup>\n\nDie Genauigkeit, d.h. die kleinste darstellbare Differenz zwischen zwei Gleitkommazahlen, ergibt sich aus der Mantisse $ m$. Eine grobe Abschätzung der Genauigkeit kann wie folgt durchgeführt werden. Per Definition deckt die Mantisse einen Zahlenbereich von 0 bis etwa 10 ab. Dieser Bereich wird in obiger Festlegung mit 52 Bit dargestellt. Hieraus ergibt sich dann der kleinste Unterschied zu\n\n* kleinster Unterschied zwischen zwei Gleitkommazahlen: 10 / 2<sup>52</sup> ~ 2·10<sup>-15</sup>\n\nBetrachtet man nun Dezimalzahlen, so entspricht das etwa der 15-ten Nachkommastelle. \n\nDer Datentyp, welcher für die Darstellung von Gleitkommazahlen verwendet wird, wird generell als *float* (engl. *floating point number*) bezeichnet. Im [IEEE754 Standard](https://de.wikipedia.org/wiki/IEEE_754) werden viele verschiedene Darstellungen definiert.\n\n## Zeichendarstellung\n\nNeben Zahlen können auch Zeichen, z.B. für die Darstellung von Text, abgebildet werden. \nDie Grundidee ist dabei, dass die Zeichen als vorzeichenlose ganze Zahlen gespeichert \nund dann anhand einer Tabelle interpretiert werden. Ein Beispiel für eine solche \nTabelle, welche den Zahlenwerte Zeichen zuordnet, ist die \n[ASCII Tabelle](https://de.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange). \nIn dieser werden 7-Bit-Zahlen, d.h. 128 Zeichen, kodiert. In der 1963 erstellten – \nund bis heute genutzten – Tabelle, sind sowohl nicht-druckbare Zeichen (z.B. \nZeilenvorschub, Tabulatorzeichen) als auf folgende druckbare Zeichen enthalten:\n\n```\n !\"#$%&'()*+,-./0123456789:;<=>?\n@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_\n`abcdefghijklmnopqrstuvwxyz{|}~\n```\n\nWobei das erste Zeichen das Leerzeichen ist.\n\n",
    "supporting": [
      "zahlendarstellung_files/figure-pdf"
    ],
    "filters": []
  }
}